<!DOCTYPE html>
<!-- saved from url=(0054)http://oak.cs.ucla.edu/classes/cs144/docker/index.html -->
<html lang="en"><!-- ***IMPORTANT***: This page is autogenerated from a markdown file
         DO NOT EDIT THIS FILE DIRECTLY.
	 Your edits will disappear when this page is regenerated  --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        span.underline{text-decoration: underline;}
        div.line-block{white-space: pre-line;}
        div.column{display: inline-block; vertical-align: top; width: 50%;}
        pre{background-color:#e7e7e7; border: solid 1px #000000; padding: 5px;}
        code{background-color:#e7e7e7; padding: 1px;}
    </style>
    <link rel="stylesheet" href="./Docker Setup and Basic Use_files/pandoc.css">
    <title>Docker Setup and Basic Use</title>
</head>
<body>
<h1 id="docker-setup-and-basic-use">Docker Setup and Basic Use</h1>
<h2 id="introduction-to-containers">Introduction to Containers</h2>
<p>Throughout the quarter, our project developments will be done inside "Docker containers." Like a virtual machine (such as VMWare, VirtualBox, and Parallels), a container technology allows running multiple isolated OS environments on a single machine, but with significantly less overhead. In particular, virtual machines run emulation at the hardware level; it creates a full-blown virtual hardware and runs a separate OS within it. In contrast, containers run emulation at the OS level; multiple containers running on a single machine share the same underlying OS kernel, but with their own filesystem and networking abstraction layer. This gives each container the illusion of running on a separate machine from others, but because they all share the same OS kernel, they incur minimal overhead.</p>
<figure>
<img src="./Docker Setup and Basic Use_files/container-vs-vm.png">
</figure>
<p>In addition, containers make it easy to create a single "container image" that includes all libraries and software tools that our app depends on. Once created, a container image can be easily deployed to a production server, so our app will run in exactly the same environment both in development and production, minimizing the possibility of "but it worked on my machine!" error.</p>
<h2 id="install-docker-app">Install Docker App</h2>
<p>Go to the <a href="https://docs.docker.com/engine/installation/">Docker Installation Page</a> and download the appropriate installer for your operating system. If you are using macOS 10.11 (El Capitan) or newer, we recommend <a href="https://docs.docker.com/docker-for-mac/install/">Docker for Mac</a> stable channel. If you are using <em>64-bit Windows 10 Pro, Enterprise, or Education Edition</em>, we recommend <a href="https://docs.docker.com/docker-for-windows/install/">Docker for Windows</a> stable channel. (If you install Docker for Windows, you will need to enable Hyper-V support feature.) If your system does not meet the requirements for Docker for Mac/Windows, install <a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>.</p>
<p><strong>Note</strong>: All UCLA Engineering students have a license for Windows 10 Education, which supports Docker for Windows. We strongly recommend "upgrading" to this version if your machine has a Windows version that does not support Docker for Windows. You can get the license key (and installation image) from the UCLA MyEngineering Web site by clicking on the "Software Download" link. Students report that the "upgrade" process is quick and painless if you are upgrading from Windows 10 Home. You just have to obtain the the product key from MyEngineering, click the "Activation" tab in Windows "Settings" and paste the new key in "change my product key". Windows then automatically downloads and upgrades to the latest build of Windows 10 Education after a short restart. (Credit to Herman Lin)</p>
<p>Once you finish installing the App, reboot your computer to ensure that all Docker drivers and programs are properly set up and running.</p>
<h2 id="run-first-docker-container">Run First Docker Container</h2>
<p>Once you finish installing Docker App, run the Docker app by clicking its icon. This will start <em>docker daemon</em> in the background, which will wait for <code>docker</code> command from the user.</p>
<p>Let us make sure that our Docker has been successfully installed by executing the following command in a command-line window (such as <a href="https://en.wikipedia.org/wiki/Terminal_(macOS)">Terminal</a> on Mac, <a href="https://en.wikipedia.org/wiki/Cmd.exe">Command Prompt</a> on Windows):</p>
<pre class="term"><code>$ docker run -it hello-world</code></pre>
<p>You need to have an Internet connection to execute the above command first time. If the above command gives an output similar to the following, congratulations! You have successfully installed Docker on your machine.</p>
<pre class="term"><code>Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
ca4f61b1923c: Pull complete
Digest: sha256:445b2fe9afea8b4aa0b2f27fe49dd6ad130dfe7a8fd0832be5de99625dad47cd
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.
...
For more examples and ideas, visit:
 https://docs.docker.com/engine/userguide/</code></pre>
<h2 id="docker-image-and-container">Docker Image and Container</h2>
<p>Now that you have successfully installed Docker, it is time to learn about important concepts related to Docker: <em>Docker image</em> and <em>Docker container</em>. Roughly speaking, a Docker image is like an OS installation package (such as a Windows installation ISO or macOS installation package) and a Docker container is like an actual system that is setup using the image (such as your laptop). Just like you can set up multiple machines using one OS installation package, it is possible to create multiple containers using one Docker image.</p>
<p>In fact, when you executed the following command earlier,</p>
<pre class="term"><code>$ docker run -it hello-world</code></pre>
<p>Docker performed the following sequence of operations</p>
<ol type="1">
<li>It first downloaded the Docker image named "hello-world" over the Internet from the <em>Docker Hub</em> and saved it locally. Docker Hub is the default location from which Docker images are downloaded.</li>
<li>It then created a Docker container based on the downloaded image.</li>
<li>Finally, it started running the container, displaying any output from the container on terminal.</li>
</ol>
<p>After Docker images and containers have been download and created, you can see the list of locally available images and containers through the following commands:</p>
<pre class="term"><code>$ docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              f2a91732366c        5 weeks ago         1.85kB</code></pre>
<p>The <code>docker image ls</code> command shows all Docker images that have been saved locally. In this example, we have the "hello-world" image that was downloaded from our earlier <code>docker run ...</code> command.</p>
<pre class="term"><code>$ docker container ls -a
CONTAINER ID  IMAGE        COMMAND   CREATED      STATUS                 PORTS  NAMES
ceb7f467442e  hello-world  "/hello"  an hour ago  Exited (0) an hour ago        loving_volhard</code></pre>
<p>The <code>docker container ls -a</code> command shows all Docker containers that have been created. Note the last "NAMES" column in the output, which has the value "loving_volhard" in this example. (This value is likely to be different on your machine.) Whenever Docker creates a new container, it assigns a unique random name -- in our example "loving_volhand" -- so that the user can refer to the container using the name in future commands. For example, if we want to start the "loving_volhard" container again, we can execute</p>
<pre class="term"><code>$ docker container start -i loving_volhard   # replace loving_volhard with your container name</code></pre>
<p>which will print out the "hello world" message on the terminal.</p>
<p><strong>NOTE:</strong> <code>docker container ls -a</code> shows all containers that have been created. If you want to see only the currently-running containers, you can use the <code>docker container ls</code> command without <code>-a</code> (<code>-a</code> means all). Also, <code>docker ps</code> and <code>docker start</code> are aliases to <code>docker container ls</code> and <code>docker container start</code>, respectively. Since <code>docker ps</code> and <code>docker start</code> require less typing, so we will use these aliases from now on.</p>
<h2 id="shared-folder-and-port-forwarding">Shared Folder and Port Forwarding</h2>
<p>In using Docker containers, there are two more important concepts that you will need to know: <em>shared folder</em> and <em>port forwarding</em>.</p>
<p>To learn about these concepts, first, create a directory on your computer where you plan to do project development. In this tutorial, we will assume to use <code>/Users/cho/cs144</code> as such a directory.</p>
<p>Then execute the following command after replacing <code>{your_shared_dir}</code> with your directory name (i.e., <code>/Users/cho/cs144/</code>):</p>
<pre class="term"><code>$ docker run -it -v {your_shared_dir}:/home/cs144/shared -p 8888:8080 --name tomcat junghoo/cs144-tomcat </code></pre>
<p>This command will ask Docker to perform the following actions:</p>
<ol type="1">
<li><em>Image name</em>: From Docker Hub, download and save the image "junghoo/cs144-tomcat".</li>
<li><em>Container name</em>: Create a container from the downloaded image and name it "tomcat" (the <code>--name tomcat</code> option).</li>
<li><em>Shared folder</em>: "Mount" the <code>{your_shared_dir}</code> (i.e., <code>/Users/cho/cs144/</code>) directory on your host machine at the <code>/home/cs144/shared</code> directory in the container Any file you place in the <code>/Users/cho/cs144</code> directory on your host machine will be available in the <code>/home/cs144/shared</code> directory of the container, and vice versa.</li>
<li><em>Port forwarding</em>: Forward any network request to port 8888 on the host machine to the port 8080 on the container (the <code>-p 8888:8080</code> option).</li>
<li><em>Interactive terminal</em>: Allocate a pseudo terminal in the container (<code>-t</code> option) and connect it to the interactive terminal window of the host (<code>-i</code> option).</li>
</ol>
<p>When you execute the above command, you are likely to see a sequence of output similar to the following:</p>
<pre class="term"><code>Unable to find image 'junghoo/cs144-tomcat' locally
latest: Pulling from junghoo/cs144-tomcat
f49cf87b52c1: Pull complete
...
Using CLASSPATH:       /usr/share/tomcat8/bin/bootstrap.jar:/usr/share/tomcat8/bin/tomcat-juli.jar
Tomcat started.
cs144@f3339ccac015:~$</code></pre>
<p>Be patient, because the image "junghoo/cs144-tomcat" is quite large (~500MB) and may take a while to download. Eventually, the "tomcat" container created from the image "junghoo/cs144-tomcat" starts MySQL and Apache Tomcat servers, and runs the <em>bash shell</em>, giving you the following prompt:</p>
<pre class="term"><code>cs144@f3339ccac015:~$</code></pre>
<p>Note that this bash shell is <em>running in the container</em>, and any command that you type now will be executed <em>inside the container</em>. For example, if you type <code>pwd</code>,</p>
<pre class="term"><code>cs144@f3339ccac015:~$ pwd
/home/cs144</code></pre>
<p>it prints <code>/home/cs144</code>, the current working directory in the container. Also, if you type <code>whoami</code>,</p>
<pre class="term"><code>cs144@f3339ccac015:~$ whoami
cs144</code></pre>
<p>it prints <code>cs144</code> which is your username in the container -- your username is <code>cs144</code> with password <code>password</code> in the container.</p>
<h3 id="port-forwarding-between-host-and-container">Port Forwarding Between Host and Container</h3>
<p>As we briefly mentioned earlier, the container starts an Apache Tomcat server when it boots up. While Tomcat server listens on port 8080 for HTTP requests, since the host's port 8888 is forwarded to the container's port 8080, the Tomcat server can be accessed at the URL <a href="http://localhost:8888/" class="uri">http://localhost:8888</a>. Open a browser from you host machine and access the URL <a href="http://localhost:8888/" class="uri">http://localhost:8888</a>. If everything is running properly, you will see a page similar to the following:</p>
<figure>
<img src="./Docker Setup and Basic Use_files/tomcat.png" width="769" height="673">
</figure>
<h3 id="shared-folder">Shared Folder</h3>
<p>All your projects in this quarter should be done within one of the containers that we provide. To make it easy to share files between your host machine and container, we created a "shared folder" between them through the option <code>-v /User/cho/cs144:/home/cs144/shared</code>. Any file that you add to the <code>/User/cho/cs144</code> directory on your host machine is accessible at the <code>/home/cs144/shared</code> directory within the container and vice versa. Add a new file to <code>/User/cho/cs144</code> on your host and verify that the file is accessible within the container. Delete the file in the container and verify that the file also disappears in <code>/User/cho/cs144</code> of the host.</p>
<h2 id="shutting-down-and-restarting-container">Shutting Down and Restarting Container</h2>
<p>Once you are done with interacting with the container, type <code>exit</code> in bash:</p>
<pre class="term"><code>cs144@f3339ccac015:~$ exit
exit
Initiating the shutdown process...
Using CATALINA_BASE:   /var/lib/tomcat8
Using CATALINA_HOME:   /usr/share/tomcat8
Using CATALINA_TMPDIR: /var/lib/tomcat8/temp
Using JRE_HOME:        /usr/lib/jvm/default-java
Using CLASSPATH:       /usr/share/tomcat8/bin/bootstrap.jar:/usr/share/tomcat8/bin/tomcat-juli.jar
Container has been shutdown...</code></pre>
<p>When the bash shell exits, the container will shut itself down, and send you back to your host machine.</p>
<p>From now on, if you need to start the "tomcat" container again, use the <code>docker start</code> command:</p>
<pre class="term"><code>$ docker start -i tomcat
Using CATALINA_BASE:   /var/lib/tomcat8
Using CATALINA_HOME:   /usr/share/tomcat8
Using CATALINA_TMPDIR: /var/lib/tomcat8/temp
Using JRE_HOME:        /usr/lib/jvm/default-java
Using CLASSPATH:       /usr/share/tomcat8/bin/bootstrap.jar:/usr/share/tomcat8/bin/tomcat-juli.jar
Tomcat started.
cs144@f3339ccac015:~$</code></pre>
<p>If you need to stop a running container from your host (not by typing <code>exit</code> within the container bash shell), you can use <code>docker stop</code> command:</p>
<pre class="term"><code>$ docker stop tomcat</code></pre>
<h2 id="docker-command-cheat-sheet">Docker-Command Cheat Sheet</h2>
<p>Here we provide a list of frequently-used docker commands. The first five commands have been used and explained in this tutorial.</p>
<ul>
<li><code>docker run -it -v /User/cho/cs144:/home/cs144/shared -p 8888:8080 --name tomcat junghoo/cs144-tomcat</code>: obtain the docker image "junghoo/cs144-tomcat" from Docker hub, create a new container named "tomcat", mount the host folder <code>/User/cho/cs144</code> at the container folder <code>/home/cs144/shared</code>, forward the localhost port 8888 to the container port 8080, and start the container interactively.</li>
<li><code>docker ps</code>: display currently-running containers</li>
<li><code>docker ps -a</code>: display all containers</li>
<li><code>docker ls</code>: display all locally-saved images</li>
<li><code>docker start -i tomcat</code>: start the container "tomcat" interactively</li>
<li><code>docker stop tomcat</code>: stop the container "tomcat"</li>
<li><code>docker exec -it tomcat /bin/bash</code>: execute the command <code>/bin/bash</code> interactively inside the running container "tomcat"</li>
<li><code>docker rm tomcat</code>: delete the container "tomcat"</li>
<li><code>docker rename tomcat tomcat2</code>: rename the container "tomcat" to "tomcat2"</li>
<li><code>docker rmi junghoo/cs144-tomcat</code>: delete the local image "junghoo/cs144-tomcat"</li>
</ul> 


</body></html>