<!DOCTYPE html>
<!-- saved from url=(0056)http://oak.cs.ucla.edu/classes/cs144/project4/index.html -->
<html lang="en"><!-- ***IMPORTANT***: This page is autogenerated from a markdown file
         DO NOT EDIT THIS FILE DIRECTLY.
	 Your edits will disappear when this page is regenerated  --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        span.underline{text-decoration: underline;}
        div.line-block{white-space: pre-line;}
        div.column{display: inline-block; vertical-align: top; width: 50%;}
        pre{background-color:#e7e7e7; border: solid 1px #000000; padding: 5px;}
        code{background-color:#e7e7e7; padding: 1px;}
        div.sourceCode { overflow-x: auto; }
        table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
          margin: 0; padding: 0; vertical-align: baseline; border: none; }
        table.sourceCode { width: 100%; line-height: 100%; }
        td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
        td.sourceCode { padding-left: 5px; }
        code > span.kw { color: #0000ff; } /* Keyword */
        code > span.ch { color: #008080; } /* Char */
        code > span.st { color: #008080; } /* String */
        code > span.co { color: #008000; } /* Comment */
        code > span.ot { color: #ff4000; } /* Other */
        code > span.al { color: #ff0000; } /* Alert */
        code > span.er { color: #ff0000; font-weight: bold; } /* Error */
        code > span.wa { color: #008000; font-weight: bold; } /* Warning */
        code > span.cn { } /* Constant */
        code > span.sc { color: #008080; } /* SpecialChar */
        code > span.vs { color: #008080; } /* VerbatimString */
        code > span.ss { color: #008080; } /* SpecialString */
        code > span.im { } /* Import */
        code > span.va { } /* Variable */
        code > span.cf { color: #0000ff; } /* ControlFlow */
        code > span.op { } /* Operator */
        code > span.bu { } /* BuiltIn */
        code > span.ex { } /* Extension */
        code > span.pp { color: #ff4000; } /* Preprocessor */
        code > span.do { color: #008000; } /* Documentation */
        code > span.an { color: #008000; } /* Annotation */
        code > span.cv { color: #008000; } /* CommentVar */
        code > span.at { } /* Attribute */
        code > span.in { color: #008000; } /* Information */
    </style>
    <link rel="stylesheet" href="./index_files/pandoc.css">
    <title></title>
</head>
<body>
<h1 id="project-4-blogging-server-on-node.js-and-mongodb">Project 4: Blogging Server on Node.js and MongoDB</h1>
<h2 id="change-history">Change history</h2>
<ol type="1">
<li>02/22/2018 10:30AM Added requirement for using port 3000 for the server</li>
<li>02/23/2018 10:05PM Added <code>postid</code> as a required field of <code>/api/:username</code></li>
<li>02/28/2018 06:52PM Added clarification on Part E editor entry point</li>
</ol>
<h2 id="overview">Overview</h2>
<p>The primary task of Project 4 is to implement the website for our markdown-based blogging service that (1) lets anyone read blogs written by our users through public URLs and (2) lets our registered users create and update their own blogs after password authentication. Through this process, we will learn how to develop a back-end service using Node.JS, Express and MongoDB.</p>
<h2 id="development-environment">Development Environment</h2>
<p>The development for Project 4 will be done using the same docker container that you created in Project 3, which can be stared with the command:</p>
<pre class="term"><code>$ docker start -i mean</code></pre>
<p>Make sure that Node.JS and MongoDB runs fine through the following commands:</p>
<pre class="term"><code>$ node --version
$ mongo -version</code></pre>
<p>In addition, we will use the <a href="https://expressjs.com/en/starter/generator.html">Express application generator</a> to generate the server skeleton code for this project. Please install it using the following command</p>
<pre class="term"><code>$ sudo npm install -g express-generator</code></pre>
<p>and make sure that it is correctly installed by running</p>
<pre class="term"><code>$ express --version</code></pre>
<h2 id="project-requirements">Project Requirements</h2>
<p>Our back-end blogging service should be accessible at the following URLs:</p>
<table>
<colgroup>
<col style="width: 2%">
<col style="width: 19%">
<col style="width: 6%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">#</th>
<th style="text-align: left;">URL</th>
<th style="text-align: left;">method</th>
<th style="text-align: left;">functionality</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;"><code>/blog/:username/:postid</code></td>
<td style="text-align: left;">GET</td>
<td style="text-align: left;">Return an HTML-formatted page that shows the blog post with <code>postid</code> written by <code>username</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: left;"><code>/blog/:username</code></td>
<td style="text-align: left;">GET</td>
<td style="text-align: left;">Return an HTML page that contains first 5 blog posts by <code>username</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: left;"><code>/login?username=:username &amp;password=:password &amp;redirect=:redirect</code></td>
<td style="text-align: left;">GET</td>
<td style="text-align: left;">If either <code>username</code> or <code>password</code> is missing or if they don't match to our record, return an HTML page with the username and password form fields. If they match, set an authentication session cookie in JSON Web Token (JWT), and redirect to <code>redirect</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td style="text-align: left;"><code>/api/:username</code></td>
<td style="text-align: left;">GET</td>
<td style="text-align: left;">This is the REST API used by the Angular blog editor to retrieve all blog posts by <code>username</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">5</td>
<td style="text-align: left;"><code>/api/:username/:postid</code></td>
<td style="text-align: left;">GET, POST, PUT, DELETE</td>
<td style="text-align: left;">This is the REST API used by the Angular blog editor to perform a CRUD operation on the user's blog post</td>
</tr>
<tr class="even">
<td style="text-align: left;">6</td>
<td style="text-align: left;"><code>/edit/</code></td>
<td style="text-align: left;">GET</td>
<td style="text-align: left;">The main URL from which the user can access the Angular blog editor app</td>
</tr>
</tbody>
</table>
<p><em>Note</em>:</p>
<ol type="1">
<li><p>The URL patterns 1-3 should be publicly accessible by anyone. No prior user authentication should be required to access these URLs. More detailed requirement for the URL pattern 2 will be given in Part B.</p></li>
<li><p>The URL patterns 4-6 should be protected behind authentication. For the URL patterns 4-5, if the authenticated username is different from the username in the URL, the server should reply with "401 (Unauthorized)" status code. For URL pattern 6, if the user has already been authenticated, the server should return the Angular app that we implemented in Project 3. Otherwise, the server should redirect the request to the URL pattern 3, so that the user can authenticate themselves.</p></li>
<li><p>The JWT session cookie set by the server after the user authenticates themselves through the URL pattern 3 should follow the format described later in Part C.</p></li>
<li><p>More detailed specifications on what the server should do for the URL patterns 4-5 are given later in Part D.</p></li>
<li><p>The implemented server should listen on <strong><em>port 3000</em></strong> for HTTP requests.</p></li>
</ol>
<p>All blog posts and the users' authentication credentials should be stored in the MongoDB server. The MongoDB server should have at least the following two collections, "Posts" and "Users", in the database "BlogServer". The two collections must have two initial documents shown below:</p>
<ol type="1">
<li><strong>Collection: Posts</strong>
<ul>
<li>{ "postid": 1, "username": "cs144", "created": 1518669344517, "modified": 1518669344517, "title": "Title 1", "body": "Hello, world!" }</li>
<li>{ "postid": 2, "username": "cs144", "created": 1518669658420, "modified": 1518669658420, "title": "Title 2", "body": "I am here." }</li>
</ul>
<p>The first collection "Posts" stores all blog posts created and saved by our users. As users write more blog posts, more documents should be inserted into this collection. Note that "created" and "modified" fields of the two documents are all integers, whose values are milliseconds since the the Unix epoch (Jan 1, 1970 UTC).</p></li>
<li><strong>Collection: Users</strong>
<ul>
<li>{ "username": "cs144", "password": "$2a$10$2DGJ96C77f/WwIwClPwSNuQRqjoSnDFj9GDKjg6X/PePgFdXoE4W6" }</li>
<li>{ "username": "user2", "password": "$2a$10$kTaFlLbfY1nnHnjb3ZUP3OhfsfzduLwl2k/gKLXvHew9uX.1blwne" }</li>
</ul>
<p>The second collection "Users" stores the users' authentication credentials. They should be used for authenticating any user to our server through the URL pattern 3. Note that <strong>users' passwords must NEVER be stored in plaintext</strong>. Instead, we have to store them only after we apply a cryptographic one-way hash function. This ensures that even if a hacker breaks into our system and gets a hold of our database, they won't be able to obtain the users' passwords easily since it is time-consuming to recover the plaintext passwords from the hash values. The downside of this approach is that when a user tries to login, we will have to apply the same cryptographic hash function to the user-provided password and then match the equivalence of this hash value to what is stored in our database. This can potentially increase the computational overhead of authenticating a user, but given the potential security risk of saving plaintext passwords, it is the cost that we are willing to pay. In our case, we applied <a href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt hash function</a> to each user's password ("password" for "cs144" and "blogserver" for "user2", respectively) using the <a href="https://www.npmjs.com/package/bcrypt">bcrypt module</a> of node.js.</p></li>
</ol>
<p>Finally, you must also change our Angular Markdown Editor of Project 3, so that it uses the REST APIs of our server -- the URL patterns 4 and 5 -- to manage the user's posts, and make it available at the URL <code>/edit/</code>.</p>
<h2 id="part-a-create-initial-mongodb-data">Part A: Create Initial MongoDB Data</h2>
<p>In Project 4, all blog posts must be managed by MongoDB. Unlike MySQL, MongoDB doesn’t have the concept of schema. All types of data are saved as <em>documents</em> in a <em>collection</em>. Since MongoDB document is essentially a JSON object, it is often a preferred back-end data storage engine for JavaScript-based development.</p>
<p>Although our Docker container has MongoDB preinstalled, the database server does not start automatically when you start the container. To start the server, run:</p>
<pre class="term"><code>$ sudo mongod --fork --logpath /var/log/mongodb/mongodb.log</code></pre>
<p>When you are done, you can stop the server with:</p>
<pre class="term"><code>$ sudo mongod --shutdown</code></pre>
<p>While the MongoDB server is running, you can start the "MongoDB command-line shell" by:</p>
<pre class="term"><code>$ mongo</code></pre>
<p>Once you are inside the shell, you can issue most MongoDB commands interactively. Go over <a href="http://oak.cs.ucla.edu/classes/cs144/notes/mongo.html">class notes on MongoDB</a> to review the basic MongoDB commands. If needed, review online tutorials on MongoDB, such as <a href="https://www.tutorialspoint.com/mongodb/index.htm">this one</a>.</p>
<p>Now <em>write a script named <code>db.sh</code> that includes the sequence of mongodb shell commands that load the following documents into the two collections, "Posts" and "Users", in the "BlogServer" database</em>:</p>
<ol type="1">
<li><strong>Collection: Posts</strong>
<ul>
<li>{ "postid": 1, "username": "cs144", "created": 1518669344517, "modified": 1518669344517, "title": "Title 1", "body": "Hello, world!" }</li>
<li>{ "postid": 2, "username": "cs144", "created": 1518669658420, "modified": 1518669658420, "title": "Title 2", "body": "I am here." }</li>
</ul></li>
<li><strong>Collection: Users</strong>
<ul>
<li>{ "username": "cs144", "password": "$2a$10$2DGJ96C77f/WwIwClPwSNuQRqjoSnDFj9GDKjg6X/PePgFdXoE4W6" }</li>
<li>{ "username": "user2", "password": "$2a$10$kTaFlLbfY1nnHnjb3ZUP3OhfsfzduLwl2k/gKLXvHew9uX.1blwne" }</li>
</ul></li>
</ol>
<p>We also provide two JSON files that contain the above documents, <a href="http://oak.cs.ucla.edu/classes/cs144/project4/posts.json" class="uri">posts.json</a> and <a href="http://oak.cs.ucla.edu/classes/cs144/project4/users.json" class="uri">users.json</a>, in case they are helpful.</p>
<p>Note that "created" and "modified" fields of the first two post documents are all integers, whose values represent the milliseconds since the the Unix epoch (Jan 1, 1970 UTC). You must store all date fields in this format. Also recall that the above password values are obtained by applying the bcrypt cryptographic one-way hash function.</p>
<p>Note that your provided script <code>db.sh</code> will be executed through the following command</p>
<pre class="term"><code>$ mongo &lt; db.sh</code></pre>
<p>before we grade your submission to initialize the MongoDB database for the server.</p>
<p><strong>Notes on CR/LF issue:</strong> If your host OS is Windows, you need to pay attention to how each line ends in your script file. Windows uses a pair of CR (carriage return) and LF (line feed) characters to terminate lines, but Unix uses only a LF character. Therefore, problems may arise when you feed a text file generated from a Windows program to a Unix tool such as <code>mongo</code>. If you encounter any wired error when you run your script, you may want to run the <code>dos2unix</code> command in the container on your script file to fix line end characters.</p>
<h2 id="part-b-implement-public-html-blog-web-pages">Part B: Implement Public HTML Blog Web Pages</h2>
<p>As the second task of Project 4, we now implement the public URLs by which any user can view blog posts published on our website. In particular, we will implement a server that returns an HTML page to an HTTP request to the following URL patterns:</p>
<table>
<colgroup>
<col style="width: 2%">
<col style="width: 19%">
<col style="width: 6%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">#</th>
<th style="text-align: left;">URL</th>
<th style="text-align: left;">method</th>
<th style="text-align: left;">functionality</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;"><code>/blog/:username/:postid</code></td>
<td style="text-align: left;">GET</td>
<td style="text-align: left;">Return an HTML-formatted page that shows the blog post with <code>postid</code> written by <code>username</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: left;"><code>/blog/:username</code></td>
<td style="text-align: left;">GET</td>
<td style="text-align: left;">Return an HTML page that contains first 5 blog posts by <code>username</code>. If the user has more than 5 posts, the page should contain a "next" button that link to the next 5 posts by the user.</td>
</tr>
</tbody>
</table>
<p>We use node.js JavaScript runtime engine and its express module to implement our back-end server. Node.js is built on Chrome's V8 JavaScript engine, which uses an event-driven, non-blocking I/O model to make it lightweight and efficient. Express is a module that provides an easy-to-use routing mechanism, HTML template integration, and third-party middleware integration. You may want to go over the <a href="http://oak.cs.ucla.edu/classes/cs144/notes/node.html">class lecture note on node.js</a> to brush up on node.js and express. If you need more detailed instruction on how to use them, <a href="https://www.w3schools.com/nodejs/default.asp">online tutorials like this</a> can be helpful. Express web site has more detailed documentation on <a href="https://expressjs.com/en/guide/routing.html">routing</a> and <a href="https://expressjs.com/en/guide/using-template-engines.html">using a template engine</a>.</p>
<h3 id="generate-server-skeleton-code">Generate Server Skeleton Code</h3>
<p>To generate our web server, we will use the express application generator. Initialize the project under a project directory (e.g. <code>blog-server</code>):</p>
<pre class="term"><code>$ express -e blog-server</code></pre>
<p>Here <code>-e</code> option makes the generated code use the "EJS" template engine for generating HTML pages from JSON. <em>You are welcome to use other template engine for your development</em>, but our project spec gives instructions for "EJS". When the above command is executed, you see the following folder and file structure within the <code>blog-server</code> directory:</p>
<pre><code>blog-server
 +- bin
 +- public
 +- routes
 +- views
 +- package.json
 +- app.js</code></pre>
<p>Here the <code>app.js</code> file serves as the entrance of the whole project. If you define other .js files, you need to reach them starting from app.js. The <code>package.json</code> file contains some meta information on the project including its "package dependencies". When you add new dependencies to this file and run <code>npm install</code>, <code>npm</code> will install all dependent modules into the subdirectory <code>node_modules</code>. The <code>public</code> directory contains static resources that are made available on the developed web site, like HTML, CSS, JavaScript, and image files. The <code>views</code> directory contains HTML template files. The <code>routes</code> directory contains "middleware" that processes the requests. The <code>bin</code> directory contains the executable file. As you develop your code, you are welcome to add or modify any directory or file as needed.</p>
<p>Make sure that the generated code works properly on our container by executing the following command:</p>
<pre class="term"><code>$ npm start</code></pre>
<p>The <code>npm start</code> command executes "test" script specified in <code>package.json</code> (which is <code>node ./bin/www</code> in the auto-generated <code>package.json</code> file). Open a web browser on your host machine and make sure that you see a page similar to the following image at <a href="http://localhost:3000/" class="uri">http://localhost:3000/</a>:</p>
<figure>
<img src="./index_files/hello.jpg" width="500">
</figure>
<h3 id="install-mongodb-and-commonmark-modules">Install mongodb and commonmark Modules</h3>
<p>To generate public HTML blog pages using node.js, express, and MongoDB, we need a MongoDB client library for node.js and a markdown-to-HTML rendering library. We will use the <a href="https://www.npmjs.com/package/mongodb">official MongoDB driver for node.js</a> and the <a href="https://www.npmjs.com/package/commonmark">commonmark.js library</a> for this purpose. Install these two packages using <code>npm</code></p>
<pre class="term"><code>$ npm install --save mongodb
$ npm install --save commonmark</code></pre>
<p>Make sure that you add the <code>--save</code> option, so that the packages are added as dependencies to <code>package.json</code>.</p>
<p>You must be familiar with <code>commonmark</code> API by now from earlier projects, but you may not be familiar with the MongoDB native client API yet. Go over <a href="http://mongodb.github.io/node-mongodb-native/3.0/quick-start/quick-start/">MongoDB native drive quick start tutorial</a> to learn the basics and read the <a href="http://mongodb.github.io/node-mongodb-native/3.0/tutorials/crud/">MongoDB tutorial on CRUD operations</a> to learn more details.</p>
<p><strong>Note:</strong> Due to a strange interaction between node, Docker container, and shared folder, you may sometimes get an error similar to the following when you run <code>node</code> or <code>npm</code>:</p>
<pre class="term"><code>path.js:1177
           cwd = process.cwd();
                        ^
Error: ENOENT: no such file or directory, uv_cwd</code></pre>
<p>If you get the above error, you can "fix it" by <code>cd ../</code>, cd back, and try again.</p>
<h3 id="learn-the-template-syntax">Learn the Template Syntax</h3>
<p>The responses to the two URL patterns shown above should be all in HTML. For generating an HTML response, you can use a <em>template engine</em>. When you use a template engine, you just need to write a static "template file", and "render" the final HTML response by combining the template with data.</p>
<p>EJS (Embedded JavaScript) uses a template syntax very similar to Java ServePages (JSP). Like JSP, you can use the standard HTML tags in the template, and sprinkle your JavaScript code inside <code>&lt;% ... %&gt;</code>, <code>&lt;%= ... %&gt;</code>, or <code>&lt;%- ... %&gt;</code> tags. <code>&lt;%= ... %&gt;</code> or <code>&lt;%- ... %&gt;</code> can include any expression and is replaced with the output string of the expression. The difference between the two is that <code>&lt;%= ... %&gt;</code> escapes HTML tags in the output, so that the HTML tags are displayed as strings, while <code>&lt;%- ... %&gt;</code> does not escape HTML tags, so that the browser can interpret them as HTML tags. <code>&lt;% ... %&gt;</code> can include any arbitrary JavaScript code, not just expressions.</p>
<p>Here is an example of a valid EJS template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul&gt;</span>
    <span class="er">&lt;</span>% for(let i = 0; i <span class="er">&lt;</span> books.length; i++) { %&gt;
        <span class="kw">&lt;li&gt;</span><span class="er">&lt;</span>%- books[i].isbn %&gt;<span class="kw">&lt;/li&gt;</span>
    <span class="er">&lt;</span>% } %&gt;
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<p>For more EJS examples, look at the generated template files in the <code>views</code> directory. You may also want to go over an <a href="https://scotch.io/tutorials/use-ejs-to-template-your-node-application">online tutorial like this</a> to learn more on EJS.</p>
<h3 id="implement-blogusernamepostid-and-blogusername">Implement <code>/blog/:username/:postid</code> and <code>/blog/:username</code></h3>
<p>Now that you know the basics to implement Part B, go ahead and implement it. The responses from <strong>these two URL patterns must meet the following requirements:</strong></p>
<ol type="1">
<li><p>All blog posts returned from the two URL patterns should be rendered in HTML from markdown using the <code>commonmark.js</code> module, both title and body.</p></li>
<li><p>The second URL pattern <code>/blog/:username</code> must return the first 5 posts by <code>username</code>. When there are more posts from the user the returned page must contain a "next" link, which points to a page with the next 5 posts by the user. <strong><em>Make sure that the "next" link is implemented as an HTML <code>&lt;a&gt;</code> element with <code>id="next"</code> and <code>href</code> pointing to the URL of the "next page".</em></strong></p></li>
<li><p>The second URL pattern <code>/blog/:username</code> must take an <em>optional query string parameter</em> <code>start=:postid</code>, like</p>
<pre><code>/blog/cs144?start=3</code></pre>
<p>When this optional query string parameter exists, the response must include the next 5 posts by <code>cs144</code> whose <code>postid</code> is 3 or above.</p></li>
</ol>
<p><strong>Note</strong>:</p>
<ol type="1">
<li>In implementing this part, remember that a request can be "routed" to a callback function through <code>app.METHOD(URL, callback)</code>, like <code>app.get('/blog/:username', callback)</code>. Inside the callback function, you can reference the HTTP request through the first <a href="http://expressjs.com/en/api.html#req">req parameter</a>, and you can generate the response through the second <a href="http://expressjs.com/en/api.html#res">res parameter</a>.</li>
<li>In our project, all dates are stored as a number in MongoDB, which represents milliseconds since the the Unix epoch (Jan 1, 1970 UTC). You can convert a JavaScript <code>Date</code> object to this number using its <code>getTime()</code> method. Conversely, you can convert this number to a <code>Date</code> object by passing it as the constructor parameter of <code>Date</code> or by calling a date object's <code>setTime()</code> method.</li>
<li>Please remember that all MongoDB commands must be executed <em>asynchronously</em> either using callback functions or using a <code>Promise</code> object (with <code>await</code> keyword).</li>
<li>To minimize the overhead from creating a connection to the database server, we strongly recommend that you create a connection to the MongoDB server when the your application starts up and reuse the created connection for all MongoDB commands. If you are unclear about how this can be done, see <a href="http://oak.cs.ucla.edu/classes/cs144/mongo/connection-pool.html">this page</a> (This page is a slightly modified version of the original blog post published <a href="https://blog.mlab.com/2013/11/deep-dive-into-connection-pooling/">here</a>.) Note that if you decide to add <code>app.listen()</code> to app.js file, you will have to remove the call to <code>listen()</code> from the "bin/www" file.</li>
</ol>
<h2 id="part-c-implement-user-login-page">Part C: Implement User Login Page</h2>
<p>In this part, we will implement the user login page available at the following URL:</p>
<table>
<colgroup>
<col style="width: 2%">
<col style="width: 19%">
<col style="width: 6%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">#</th>
<th style="text-align: left;">URL</th>
<th style="text-align: left;">method</th>
<th style="text-align: left;">functionality</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;"><code>/login?username=:username &amp;password=:password &amp;redirect=:redirect</code></td>
<td style="text-align: left;">GET</td>
<td style="text-align: left;">If either <code>username</code> or <code>password</code> is missing or if they don't match to our record, return an HTML page with the username and password form fields. If they match, set an authentication session cookie in JSON Web Token (JWT), and redirect to <code>redirect</code>.</td>
</tr>
</tbody>
</table>
<p>Recall that our MongoDB server stores all users' credentials in the "Users" collection of the "BlogServer" database. In addition, recall that the stored user passwords are all hash values obtained by applying the bcrypt hash function. Therefore, to match a user's stored password against what she provides during authentication, you will need to use node.js <a href="https://www.npmjs.com/package/bcrypt">bcrypt module</a>. Install the module through the following command:</p>
<pre class="term"><code>$ npm install --save bcrypt</code></pre>
<p>Read the <a href="https://www.npmjs.com/package/bcrypt">bcrypt package page</a> to learn how you can use it to compare a user's password against a hash value.</p>
<h3 id="json-web-token-jwt">JSON Web Token (JWT)</h3>
<p>Once the user's authenticity is established through the user-provided password, our server must establish a "authenticated session", so that it can recognize that any future request coming from the same browser comes from the authenticated user. There are a number of ways to implement this. In this project, you must use <a href="https://jwt.io/">JSON Web Token (JWT)</a> for this purpose. If you are not familiar with JWT, go over the <a href="https://jwt.io/introduction/">JWT introduction page</a> to learn what it is and how it can be used.</p>
<p>In your implementation, once the user is authenticated, you must set a <em>transient session cookie</em> (a cookie that has no expiration date, so that it is forgotten once the browser is closed) whose name is <code>jwt</code> and whose value is the following JWT:</p>
<ol type="1">
<li><p>Its header must have two claims, 'alg' (algorithm) and 'typ' (type), with the following values:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="st">"alg"</span><span class="op">:</span> <span class="st">"HS256"</span><span class="op">,</span>
  <span class="st">"typ"</span><span class="op">:</span> <span class="st">"JWT"</span>
<span class="op">}</span></code></pre></div></li>
<li><p>Its payload must have two claims, 'exp' (expiration time) and 'usr' (user)</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="st">"exp"</span><span class="op">:</span> expiration<span class="op">,</span>
  <span class="st">"usr"</span><span class="op">:</span> <span class="st">"username"</span>
<span class="op">}</span></code></pre></div>
<p>where <code>expiration</code> should be two hours from now (in <strong><em>seconds</em></strong> since Unix epoch, Jan 1, 1970) and <code>username</code> should be the authenticated username. Note that the unit of time here is seconds not milliseconds. According to JWT standard, this is how the expiration time should be represented.</p></li>
<li><p>The signature must be generated using the HS256 algorithm (HMAC-SHA256 hash function) with the following secret key</p>
<pre><code>C-UFRaksvPKhx1txJYFcut3QGxsafPmwCY6SCly3G6c</code></pre></li>
</ol>
<p>Once this JWT cookie is set, our server will be able to recognize that any future request from the browser comes from the authenticated user <code>username</code>.</p>
<p>You can use the <a href="https://www.npmjs.com/package/jsonwebtoken">jsonwebtoken module</a> to construct a JWT. Install it with the following command</p>
<pre class="term"><code>$ npm install --save jsonwebtoken</code></pre>
<p>and learn how to use it by going over examples in the <a href="https://www.npmjs.com/package/jsonwebtoken">jsonwebtoken module page</a>.</p>
<p>Now implement the login page. Remember that after a successful authentication by the user (i.e., the user's username and password match), the server should generate an appropriate JWT, set it as the value of the cookie <code>jwt</code>, and <em>redirect the request to the <code>redirect</code> query parameter in the request.</em> If the authentication fails, (username or password is missing or they don't match with our record), the server must return a page with the username and password input box, so that they user can try again.</p>
<p>Remember that the user "cs144"'s password is "password" and "user2"'s password is "blogserver" in testing your authentication page.</p>
<h2 id="part-d-implement-blog-management-rest-api">Part D: Implement Blog-Management REST API</h2>
<p>In this part, you will have to implement the REST API that will be used by our Angular-based editor to save, retrieve, update, and delete the blog posts from the server.</p>
<table>
<colgroup>
<col style="width: 2%">
<col style="width: 19%">
<col style="width: 6%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">#</th>
<th style="text-align: left;">URL</th>
<th style="text-align: left;">method</th>
<th style="text-align: left;">functionality</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;"><code>/api/:username</code></td>
<td style="text-align: left;">GET</td>
<td style="text-align: left;">This is the REST API used by the Angular blog editor to retrieve all blog posts by <code>username</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: left;"><code>/api/:username/:postid</code></td>
<td style="text-align: left;">GET, POST, PUT, DELETE</td>
<td style="text-align: left;">This is the REST API used by the Angular blog editor to perform a CRUD operation on the user's blog post</td>
</tr>
</tbody>
</table>
<p>Here are more detailed descriptions of the above API:</p>
<ol type="1">
<li><p><strong>GET /api/:username</strong>: The server should return all blog posts by <code>username</code>. The returned posts should be included in the body of the response as an array in JSON even if the user has zero or one post. Each post in the array must have at least five fields, <code>postid</code>, <code>title</code>, <code>body</code>, <code>created</code>, and <code>modified</code> (case sensitive). The response status code should be "200 (OK)".</p></li>
<li><p><strong>GET /api/:username/:postid</strong>: The server should return the blog post with <code>postid</code> by <code>username</code>. If such a post exists, the response status code should be "200 (OK)", and the post should be included in the body of the response in JSON with at least four fields, <code>title</code>, <code>body</code>, <code>created</code>, and <code>modified</code> (case sensitive). If not, the response status code should be "404 (Not found)".</p></li>
<li><p><strong>POST /api/:username/:postid</strong>: When the server gets this request, it must insert a <em>new</em> blog post with <code>username</code>, <code>postid</code>, <code>title</code>, and <code>body</code> from the request. The request must include <code>title</code> and <code>body</code> in its body in JSON. The <code>created</code> and <code>modified</code> fields of the inserted post should be set to the current time. If the insertion is successful, the server should reply with "201 (Created)" status code. If a blog post with the same <code>postid</code> by <code>username</code> already exists in the server, the server should not insert a new post and reply with "400 (Bad request)" status code.</p></li>
<li><p><strong>PUT /api/:username/:postid</strong>: The request must include <code>title</code> and <code>body</code> in its body in JSON. When the server gets this request, it must update the <em>existing blog post</em> with <code>postid</code> by <code>username</code> with the <code>title</code> and <code>body</code> values from the request. The <code>modified</code> field should be updated to the current time as well. If the update is successful, the server should reply with "200 (OK)" status code. If there is no blog post with <code>postid</code> by <code>username</code>, the server should reply with "400 (Bad request)" status code.</p></li>
<li><p><strong>DELETE /api/:username/:postid</strong>: When the server gets this request, the server must delete the existing blog post with <code>postid</code> by <code>username</code> from the database. If the deletion is successful, the server should reply with "204 (No content)" status code. If there is no such post, the server should reply with "400 (Bad request)" status code.</p></li>
<li><p>All dates transmitted should be in <strong>milliseconds since the the Unix epoch (Jan 1, 1970 UTC) in number type</strong>.</p></li>
<li><p>If a request does not meet our requirements (such as not formatting data in JSON, not including required data, etc.), the server must reply with "400 (Bad request)" status code.</p></li>
<li><p>This REST API must be protected behind authentication. That is, if the request to this API does not contain a valid jwt cookie with matching username (i.e., if the jwt cookie is not included in the HTTP header, if the included jwt has expired, or if the username in jwt does not match the username in the URL), the server must reply with "401 (Unauthorized)" status code.</p></li>
</ol>
<p>Now add the appropriate routing instruction to your app and implement the above API. Make sure that the implementation works as intended before you proceed. You can test your implementation using the <a href="https://curl.haxx.se/docs/manpage.html">curl command</a>, which can send any HTTP request to a server from command line.</p>
<p>Once you made sure that everything works fine, protect this REST API behind authentication. That is, before you process any request to this API, first make sure that the request contains a valid jwt cookie with the matching username.</p>
<h2 id="part-e-update-angular-editor-client-for-server-based-storage">Part E: Update Angular Editor Client for Server-based Storage</h2>
<p>After you finish implementing the REST API, the final step is to connect it with the Angular editor you developed in Project 3. Your previous implementation of <code>BlogService</code> managed all blog posts locally through <code>localStorage</code>. Your new implementation must use the REST API of Part D to manage them at the server.</p>
<p>Roughly, your new implementation of <code>BlogService</code> should perform the following actions in its methods:</p>
<ol type="1">
<li><p><strong>fetchPosts(): void</strong> – This method must “populate” the <code>posts</code> property by retrieving all blog posts of the current user (whose <code>username</code> can be obtained from the jwt cookie). Send a GET request to <code>/api/:username</code> after setting up the response event handler, which populates <code>posts</code> property from the response.</p></li>
<li><p><strong>getPosts(): Post[]</strong> – It is unlikely that you have to modify this method in Project 4. This method simply returns <code>posts</code>.</p></li>
<li><p><strong>getPost(id: number): Post</strong> – It is unlikely that you have to modify this method in Project 4. Find the post with postid=<code>id</code> from <code>posts</code> and return it.</p></li>
<li><p><strong>newPost(): Post</strong> – Create a new post with a new postid, an empty title and body, and the current creation and modification times, add it to <code>posts</code>, send a <code>POST</code> request to <code>/api/:username/:postid</code> (after setting up the response event handler), and return the newly created post.</p>
<p>The response handler should do nothing if the response status code is "201 (Created)". Otherwise, it should delete the newly created post from <code>posts</code>, display an alert message saying that there was an error creating a new post at the server, and navigate to <code>/</code>, the "list pane" of the editor.</p></li>
<li><p><strong>updatePost(post: Post): void</strong> – From <code>posts</code>, find a post whose postid is the same as <code>post.postid</code>, update its title and body with the passed-in values, change its modification time to now, and send a <code>PUT</code> request to <code>/api/:username/:postid</code> (after setting up the response event handler). If no such post exists, do nothing.</p>
<p>The response event handler should do nothing if the response status code is "200 (OK)". Otherwise, it should display an alert message saying that there was an error updating the post at the server, and navigate to the "edit view" of the post.</p></li>
<li><p><strong>deletePost(postid: number): void</strong> – From <code>posts</code>, find a post whose postid is the same as the passed in value, delete it from <code>posts</code>, and send a <code>DELETE</code> request to <code>/api/:username/:postid</code> (after setting up the response event handler). If no such post exists, do nothing.</p>
<p>The response event handler should do nothing if the response status code is "204 (No content)". Otherwise, it should display an alert message saying that there was an error deleting the post at the server, and navigate to <code>/</code>, the "list pane" of the editor.</p></li>
</ol>
<p>The HTTP request to the server can be sent through various mechanisms, such as <a href="https://xhr.spec.whatwg.org/">XMLHttpRequest object</a> or <a href="https://angular.io/guide/http">HttpClient object</a> in Angular. If you decide to use <code>HttpClient</code>, you may need a basic understanding on the concept of "observable" (or event stream) and "observer" (or subscriber). If you feel that you need to learn more on this, there exist a number of good online introductory materials, such as <a href="https://en.wikipedia.org/wiki/Observer_pattern">observer pattern Wikipedia entry</a> or <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">this tutorial on reactive programming</a>.</p>
<p>Within a browser, cookies are accessible through <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie"><code>document.cookie</code></a>. Once you obtain the JWT from the cookie, you can obtain the authenticated username from it. You can use the jsonwebtoken module for this purpose, so you may want to install the module in your Angular project using the following command:</p>
<pre class="term"><code>$ npm install --save jsonwebtoken</code></pre>
<p>Eventually, your revised Angular app must be deployed to your node/express server, but during the development of Part E, you may want to run your Angular app through the "ng serve" command, so that you can test, revise, and iterate. Unfortunately, running Angular app through <code>ng serve</code> has a few unintended consequences:</p>
<ol type="1">
<li><p>You have to run two servers -- the node/express server through <code>npm start</code> and the angular app through <code>ng serve --host 0.0.0.0</code> -- within the same container. Running two servers simultaneously can be done by executing the two commands <em>in the background</em> like the following:</p>
<pre class="term"><code>$ npm start &amp;
$ ng serve --host 0.0.0.0 &amp;</code></pre>
<p>If you are not familiar with the Unix process control and job management, read the <a href="http://oak.cs.ucla.edu/classes/cs144/unix/unix5.html">Process section of our Unix tutorial</a>.</p></li>
<li><p>Your Angular app is loaded from <a href="http://localhost:4200/" class="uri">http://localhost:4200</a> but your Express server runs at <a href="http://localhost:3000/" class="uri">http://localhost:3000</a>. This means that your Angular app may not be able to use the JWT cookie set by the Express server due to cross-origin restrictions, which won't be the case once your Angular app is deployed to the Express server. To get around this problem, you have to <strong><em>allow third-party cookies</em></strong> and may use Chrome's <code>--disable-web-security --user-data-dir</code> option. To use this option, quit all running instances of your Chrome browser, and start a new instance of Chrome by executing:</p>
<pre class="term"><code>(On macOS)   $ open -a Google\ Chrome --args --disable-web-security --user-data-dir
(On Windows) $ start chrome --disable-web-security --user-data-dir</code></pre>
<p>from a terminal.</p>
<p>In addition, when your Angular app is deployed to the Express server, the server will ensure that the user is authenticated before they can access the Angular app. Unfortunately, this is not the case when your app is loaded from its own server; when your Angular app runs, it may not have a proper JWT cookie during development. Therefore, you will have to explicitly visit the Express server's login page <code>/login</code> first, authenticate yourself, and obtain a proper JWT cookie from the server before you load your Angular app. Otherwise, your browser (and Angular app) won't have a proper JWT cookie to access the Express server.</p>
<p>Due to all these complexities, we recommend disabling the REST-API authentication checking mechanism of your Express server while you are developing Part E. This will make most (but not all) headaches from JWT-cookie-related issues go away.</p></li>
</ol>
<p><strong>Note</strong>: When you run your Angular app in Chrome, Chrome developer console will throw an error for every 4XX or 5XX response from a server. Unfortunately, there doesn't seem to be any way to "catch" it to make it disappear. As long as you handle these responses according to our spec, you won't have to worry about this Chrome console error.</p>
<p>Once you finish revising <code>BlogService</code>, build the final Angular application by the command <code>ng build</code> and place the produced files in <code>dist/</code> to the <code>edit</code> subdirectory of your Express server's public folder. Before you build your Angular app, make sure to modify the base URL of the app to <code>/edit/</code> by changing the base tag in the file <code>src/index.html</code></p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base</span><span class="ot"> href=</span><span class="st">"/edit/"</span><span class="kw">&gt;</span></code></pre></div>
<p><strong>Note:</strong> To simplify this part of the project, you may assume that the first entry point to the blog post editor is always <code>/edit/</code>. That is, users never access the editor through the edit page <code>/edit/#/edit/:postid</code> or the preview page <code>/edit/#/preview/:postid</code> as the first entry point. Therefore, you may assume that the user's all blog posts are ready and available by the time either Edit or Preview Components are rendered.</p>
<p>Again, remember that any access to the <code>/edit/</code> directory should be protected behind authentication. If any request to the URL pattern <code>/edit/</code> does not include a valid JWT cookie, the request should be redirected to the login page <code>/login?redirect=/edit/</code>.</p>
<h2 id="what-to-submit">What to Submit</h2>
<p>For this project, you will have to submit <strong><em>two zip files</em></strong>:</p>
<ol type="1">
<li><code>project4.zip</code>: You need to create this zip file using the packaging script provided below. This file will contain all source codes that you wrote for Parts A through D, and the Angular application built from the modified Angular source code.</li>
<li><code>project3.zip</code>: You must create <code>project3.zip</code> file again using the packaging script of Project 3, including all the changes that you made as part of Part E of this project.</li>
</ol>
<h3 id="creating-project4.zip">Creating <code>project4.zip</code></h3>
<p>Before you create the submission zip file for Project 4, please make sure that your server can be executed simply by running the following sequence of commands at the project root directory:</p>
<pre class="term"><code>$ mongo &lt; db.sh
$ npm start</code></pre>
<p>Since this is how our grader will run and test your code, it is essential that your code runs fine without any problem through the above commands. In particular, please make sure that your modified Angular is in the <code>/edit/</code> subdirectory of your public folder, so that it is available when we run your server. We won't be building and/or copying your Angular code separately. You have to place them in the correct directory of your submission.</p>
<p>You may assume that the MongoDB server is running with no documents inside the "BlogServer" database when your your server is executed in the grader's machine.</p>
<p>After you have checked there is no issue with your project, you can package your work by running our <a href="http://oak.cs.ucla.edu/classes/cs144/project4/package.sh">packaging script</a>. Please first create the <em>TEAM.txt</em> file. This file must include the 9-digit university ID (UID) of every team member, <strong>one UID per line. No spaces or dashes.</strong> Just 9-digit UID per line. If you are working on your own, include just your UID. Please make sure <strong>TEAM.txt, db.sh and package.sh are placed in the project-root directory</strong>, <em>blog-server</em>, like this:</p>
<pre><code>blog-server
 +- bin
 +- public
 +- routes
 +- views
 +- ...
 +- package.json
 +- app.js
 +- db.sh
 +- package.sh
 +- TEAM.txt</code></pre>
<p>When you execute the packaging script like <code>./package.sh</code>, it will check whether a few mandatory files are there, and package everything within the project directory (except the files in <code>node_modules/</code>) and create a file named <code>project4.zip</code>.</p>
<p>If everything goes smoothly, you will see something like the following:</p>
<pre class="term"><code>[SUCCESS] Created '/home/cs144/shared/blog-server/project4.zip', please submit it to CCLE.</code></pre>
<p><strong>Please only submit this script-created project4.zip to CCLE. Do not use any other ways to package or submit your work!</strong></p>
<h3 id="creating-project3.zip">Creating <code>project3.zip</code></h3>
<p>While we won't be compiling and testing your modified Angular Markdown Editor ourselves --- for grading, we will simply use the prebuilt Angular code that you include in <code>project4.zip</code> --- we still want to get a working version of your modified source code for reference. Please run the <a href="http://oak.cs.ucla.edu/classes/cs144/project3/package.sh">packaging script of Project 3</a> within your project 3 folder that includes your Part E modification, create a new <code>project3.zip</code> file and submit it together with <code>project4.zip</code> to CCLE.</p>
<h2 id="grading-criteria">Grading Criteria</h2>
<p>The grading of Project 4 will be based on the following aspects:</p>
<ul>
<li><strong>The server can work</strong>: You will get 0 if your server fails to work with <code>npm start</code>!</li>
<li><strong>Interaction with Database</strong>: The grader should be able to load the initial documents into the two collections using your <code>db.sh</code> script as is described in this spec. All the posts should be stored into and retrieved from MongoDB.</li>
<li><strong>Functionality</strong>: It should implement all the specified functions, i.e. list, insert, read, update and delete in the required way. You must implement REST APIs.</li>
<li><strong>URL Navigation</strong>: Users should be able to visit the corresponding contents by directly typing the corresponding URL as is described in this spec.</li>
<li><strong>Access Control</strong>: The HTMP pages must be public; while the editor and REST API can be accessed only after login.</li>
<li><strong>Error Handling</strong>: Your server should handle different kinds of errors properly.</li>
<li><strong>Other Requirements in Description</strong>: For example, the <code>next</code> button in the <code>/blog/:username</code> page, which shows 5 posts each time.</li>
</ul> 


</body></html>