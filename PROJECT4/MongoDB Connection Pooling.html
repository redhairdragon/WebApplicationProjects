<!DOCTYPE html>
<!-- saved from url=(0063)http://oak.cs.ucla.edu/classes/cs144/mongo/connection-pool.html -->
<html lang="en"><!-- ***IMPORTANT***: This page is autogenerated from a markdown file
         DO NOT EDIT THIS FILE DIRECTLY.
	 Your edits will disappear when this page is regenerated  --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        span.underline{text-decoration: underline;}
        div.line-block{white-space: pre-line;}
        div.column{display: inline-block; vertical-align: top; width: 50%;}
        pre{background-color:#e7e7e7; border: solid 1px #000000; padding: 5px;}
        code{background-color:#e7e7e7; padding: 1px;}
        div.sourceCode { overflow-x: auto; }
        table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
          margin: 0; padding: 0; vertical-align: baseline; border: none; }
        table.sourceCode { width: 100%; line-height: 100%; }
        td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
        td.sourceCode { padding-left: 5px; }
        code > span.kw { color: #0000ff; } /* Keyword */
        code > span.ch { color: #008080; } /* Char */
        code > span.st { color: #008080; } /* String */
        code > span.co { color: #008000; } /* Comment */
        code > span.ot { color: #ff4000; } /* Other */
        code > span.al { color: #ff0000; } /* Alert */
        code > span.er { color: #ff0000; font-weight: bold; } /* Error */
        code > span.wa { color: #008000; font-weight: bold; } /* Warning */
        code > span.cn { } /* Constant */
        code > span.sc { color: #008080; } /* SpecialChar */
        code > span.vs { color: #008080; } /* VerbatimString */
        code > span.ss { color: #008080; } /* SpecialString */
        code > span.im { } /* Import */
        code > span.va { } /* Variable */
        code > span.cf { color: #0000ff; } /* ControlFlow */
        code > span.op { } /* Operator */
        code > span.bu { } /* BuiltIn */
        code > span.ex { } /* Extension */
        code > span.pp { color: #ff4000; } /* Preprocessor */
        code > span.do { color: #008000; } /* Documentation */
        code > span.an { color: #008000; } /* Annotation */
        code > span.cv { color: #008000; } /* CommentVar */
        code > span.at { } /* Attribute */
        code > span.in { color: #008000; } /* Information */
    </style>
    <link rel="stylesheet" href="./MongoDB Connection Pooling_files/pandoc.css">
    <title>MongoDB Connection Pooling</title>
</head>
<body>
<h1 id="mongodb-connection-pooling">MongoDB Connection Pooling</h1>
<p>This is a slightly modified version of the <a href="https://blog.mlab.com/2013/11/deep-dive-into-connection-pooling/">original blog article</a> posted by <a href="https://blog.mlab.com/author/chris/">Chris Chang</a> of mLab on 11/06/2013.</p>
<h2 id="connection-pools">Connection pools</h2>
<p>As your application grows in functionality and/or usage, managing resources becomes increasingly important. Failure to properly utilize connection pooling is one major "gotcha" that we've seen greatly impact MongoDB performance and trip up developers of all levels.</p>
<p>Creating new authenticated connections to the database is expensive. So, instead of creating and destroying connections for each request to the database, you want to re-use existing connections as much as possible. This is where connection pooling comes in.</p>
<p>A <em>connection pool</em> is a cache of database connections maintained by your driver so that connections can be re-used when new connections to the database are required. When properly used, connection pools allow you to minimize the frequency and number of new connections to your database.</p>
<h3 id="connection-churn">Connection churn</h3>
<p>Used improperly however, or not at all, your application will likely open and close new database connections too often, resulting in what we call "connection churn". In a high-throughput application this can result in a constant flood of new connection requests to your database which will adversely affect the performance of your database and your application.</p>
<h3 id="opening-too-many-connections">Opening too many connections</h3>
<p>Alternately, although less common, is the problem of creating too many MongoClient objects that are never closed. &nbsp;In this case, instead of churn, you get a steady increase in the number of connections to your database such that you have tens of thousands of connections open when your application could almost certainly do&nbsp;with far fewer. Since each connection takes RAM, you may find yourself wasting a good portion of your memory on connections which will also adversely affect your application's performance.</p>
<p>Although every application is different and the total number of connections to your database will greatly depend on how many client processes or application servers are connected, in our experience, any connection count greater than 1000 - 1500 connections should raise an eyebrow, and most of the time your application will require far fewer than that.</p>
<h2 id="mongoclient-and-connection-pooling">MongoClient and connection pooling</h2>
<p>Most MongoDB language drivers implement the MongoClient class which, if used properly, will handle connection pooling for you automatically.</p>
<p>Let's look at a concrete example using the Node.js driver. Creating new connections to the database using the Node.js driver is done like this:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">const</span> MongoClient <span class="op">=</span> <span class="at">require</span>(<span class="st">'mongodb'</span>).<span class="at">MongoClient</span><span class="op">;</span>
<span class="kw">const</span> assert <span class="op">=</span> <span class="at">require</span>(<span class="st">'assert'</span>)<span class="op">;</span>

<span class="co">// connection URL</span>
<span class="kw">const</span> url <span class="op">=</span> <span class="st">'mongodb://localhost:27017/dbName'</span><span class="op">;</span>

<span class="co">// Use connect method to connect to the server</span>
<span class="va">MongoClient</span>.<span class="at">connect</span>(url<span class="op">,</span> <span class="kw">function</span>(err<span class="op">,</span> db) <span class="op">{</span>
  <span class="va">assert</span>.<span class="at">equal</span>(<span class="kw">null</span><span class="op">,</span> err)<span class="op">;</span>
  <span class="va">console</span>.<span class="at">log</span>(<span class="st">"Connected successfully to dbName"</span>)<span class="op">;</span>
  <span class="va">db</span>.<span class="at">close</span>()<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span></code></pre></div>
<p>When you create a connection using MongoClient, <strong><em>you want to call 'connect' once during your apps initialization phase vs. on each database request</em></strong>. Let's take a closer look at the difference between doing the right thing vs. doing the wrong thing.</p>
<p>First, consider the following example:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">let</span> express <span class="op">=</span> <span class="at">require</span>(<span class="st">'express'</span>)<span class="op">;</span>
<span class="kw">let</span> MongoClient <span class="op">=</span> <span class="at">require</span>(<span class="st">'mongodb'</span>).<span class="at">MongoClient</span><span class="op">;</span>
<span class="kw">let</span> app <span class="op">=</span> <span class="at">express</span>()<span class="op">;</span>

<span class="kw">const</span> MONGODB_URI <span class="op">=</span> <span class="st">'mongo-uri'</span><span class="op">;</span>

<span class="va">app</span>.<span class="at">get</span>(<span class="st">'/'</span><span class="op">,</span> <span class="kw">function</span>(req<span class="op">,</span> res) <span class="op">{</span> 
  
  <span class="co">// BAD! Creates a new connection pool for every request</span>
  
  <span class="va">MongoClient</span>.<span class="at">connect</span>(MONGODB_URI<span class="op">,</span> <span class="kw">function</span>(err<span class="op">,</span> db) <span class="op">{</span>
    <span class="cf">if</span> (err) <span class="cf">throw</span> err<span class="op">;</span>
  
    <span class="va">db</span>.<span class="at">collection</span>(<span class="st">'test'</span>).<span class="at">find</span>(<span class="op">{},</span> <span class="kw">function</span>(err<span class="op">,</span> docs) <span class="op">{</span>
      <span class="va">docs</span>.<span class="at">each</span>(<span class="kw">function</span>(err<span class="op">,</span> doc) <span class="op">{</span>
        <span class="cf">if</span>(doc) <span class="op">{</span>
          <span class="va">res</span>.<span class="at">write</span>(<span class="va">JSON</span>.<span class="at">stringify</span>(doc) <span class="op">+</span> <span class="st">""</span>n<span class="st">");</span>
        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
          <span class="va">res</span>.<span class="at">end</span>()<span class="op">;</span>
        <span class="op">}</span>
      <span class="op">}</span>)<span class="op">;</span>
    <span class="op">}</span>)<span class="op">;</span>
  <span class="op">}</span>)<span class="op">;</span>  
<span class="op">}</span>)<span class="op">;</span>

<span class="va">app</span>.<span class="at">listen</span>(<span class="dv">3000</span>)<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="st">'Listening on port 3000'</span>)<span class="op">;</span></code></pre></div>
<p>The above example (no pooling) is <strong>bad</strong> for a number of reasons:</p>
<ul>
<li>It calls connect() in <em>every request handler</em>.</li>
<li>It establishes new connections for every request (connection churn).</li>
<li>It initializes the app (app.listen()) before database connections are made.</li>
</ul>
<p>Contrast the above example to the following:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">let</span> express <span class="op">=</span> <span class="at">require</span>(<span class="st">'express'</span>)<span class="op">;</span>
<span class="kw">let</span> MongoClient <span class="op">=</span> <span class="at">require</span>(<span class="st">'mongodb'</span>).<span class="at">MongoClient</span><span class="op">;</span>
<span class="kw">let</span> app <span class="op">=</span> <span class="at">express</span>()<span class="op">;</span>

<span class="kw">const</span> MONGODB_URI <span class="op">=</span> <span class="st">'mongo-uri'</span><span class="op">;</span>
<span class="kw">let</span> db<span class="op">;</span>

<span class="co">// Initialize connection once, reuse the database object </span>

<span class="va">MongoClient</span>.<span class="at">connect</span>(MONGODB_URI<span class="op">,</span> <span class="kw">function</span>(err<span class="op">,</span> database) <span class="op">{</span>
  db <span class="op">=</span> database<span class="op">;</span>
  <span class="va">app</span>.<span class="at">listen</span>(<span class="dv">3000</span>)<span class="op">;</span>
  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'Listening on port 3000'</span>)<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">app</span>.<span class="at">get</span>(<span class="st">'/'</span><span class="op">,</span> <span class="kw">function</span>(req<span class="op">,</span> res) <span class="op">{</span> 
  <span class="va">db</span>.<span class="at">collection</span>(<span class="st">'test'</span>).<span class="at">find</span>(<span class="op">{},</span> <span class="kw">function</span>(err<span class="op">,</span> docs) <span class="op">{</span>
    <span class="va">docs</span>.<span class="at">each</span>(<span class="kw">function</span>(err<span class="op">,</span> doc) <span class="op">{</span>
      <span class="cf">if</span>(doc) <span class="op">{</span>
        <span class="va">res</span>.<span class="at">write</span>(<span class="va">JSON</span>.<span class="at">stringify</span>(doc) <span class="op">+</span> <span class="st">""</span>n<span class="st">");</span>
      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
        <span class="va">res</span>.<span class="at">end</span>()<span class="op">;</span>
      <span class="op">}</span>
    <span class="op">}</span>)<span class="op">;</span>
  <span class="op">}</span>)<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">app</span>.<span class="at">get</span>(<span class="st">'/post'</span><span class="op">,</span> <span class="kw">function</span>(req<span class="op">,</span> res) <span class="op">{</span>
  <span class="va">db</span>.<span class="at">collection</span>(<span class="st">'test'</span>).<span class="at">insert</span>(<span class="op">{</span> <span class="dt">docid</span><span class="op">:</span> <span class="va">Math</span>.<span class="at">random</span>() <span class="op">},</span> <span class="kw">function</span>(err) <span class="op">{</span>
    <span class="va">res</span>.<span class="at">end</span>(<span class="st">'Successful Insert!'</span>)<span class="op">;</span>
  <span class="op">}</span>)
<span class="op">}</span>)<span class="op">;</span></code></pre></div>
<p>This example (with pooling) is better than the first for the following reasons:</p>
<ul>
<li>It calls connect() once.</li>
<li>It reuses the database variable (reuses existing connections).</li>
<li>It waits until the database connection is established before it starts listening on the network port.</li>
</ul>
<p>If you run the first example and refresh your browser enough times, you'll quickly see that your MongoDB has a hard time handling the flood of connections and will terminate.</p>
<h2 id="further-consideration---connection-pool-size">Further consideration - connection pool size</h2>
<p>Most MongoDB drivers support a parameter that sets the max number of connections (pool size) available to your application. The connection pool size can be thought of as the max number of concurrent requests that your driver can service. The default pool size for the node driver is 5. If you anticipate your application receiving many concurrent or long-running requests, we recommend increasing your pool size- adjust accordingly!</p> 


</body></html>