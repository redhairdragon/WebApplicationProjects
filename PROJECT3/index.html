<!DOCTYPE html>
<!-- saved from url=(0056)http://oak.cs.ucla.edu/classes/cs144/project3/index.html -->
<html lang="en"><!-- ***IMPORTANT***: This page is autogenerated from a markdown file
         DO NOT EDIT THIS FILE DIRECTLY.
	 Your edits will disappear when this page is regenerated  --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        span.underline{text-decoration: underline;}
        div.line-block{white-space: pre-line;}
        div.column{display: inline-block; vertical-align: top; width: 50%;}
        pre{background-color:#e7e7e7; border: solid 1px #000000; padding: 5px;}
        code{background-color:#e7e7e7; padding: 1px;}
        div.sourceCode { overflow-x: auto; }
        table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
          margin: 0; padding: 0; vertical-align: baseline; border: none; }
        table.sourceCode { width: 100%; line-height: 100%; }
        td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
        td.sourceCode { padding-left: 5px; }
        code > span.kw { color: #0000ff; } /* Keyword */
        code > span.ch { color: #008080; } /* Char */
        code > span.st { color: #008080; } /* String */
        code > span.co { color: #008000; } /* Comment */
        code > span.ot { color: #ff4000; } /* Other */
        code > span.al { color: #ff0000; } /* Alert */
        code > span.er { color: #ff0000; font-weight: bold; } /* Error */
        code > span.wa { color: #008000; font-weight: bold; } /* Warning */
        code > span.cn { } /* Constant */
        code > span.sc { color: #008080; } /* SpecialChar */
        code > span.vs { color: #008080; } /* VerbatimString */
        code > span.ss { color: #008080; } /* SpecialString */
        code > span.im { } /* Import */
        code > span.va { } /* Variable */
        code > span.cf { color: #0000ff; } /* ControlFlow */
        code > span.op { } /* Operator */
        code > span.bu { } /* BuiltIn */
        code > span.ex { } /* Extension */
        code > span.pp { color: #ff4000; } /* Preprocessor */
        code > span.do { color: #008000; } /* Documentation */
        code > span.an { color: #008000; } /* Annotation */
        code > span.cv { color: #008000; } /* CommentVar */
        code > span.at { } /* Attribute */
        code > span.in { color: #008000; } /* Information */
    </style>
    <link rel="stylesheet" href="./index_files/pandoc.css">
    <title></title>
</head>
<body>
<h1 id="project-3-markdown-editor-using-angular">Project 3: Markdown Editor Using Angular</h1>
<h2 id="change-history">Change history</h2>
<ol type="1">
<li><strong>02/12/2018 6:10PM</strong> Added clarification on when to save user's unsaved modification and information on how it may be implemented.</li>
</ol>
<h2 id="overview">Overview</h2>
<p>In this project, you will learn and use <a href="https://angular.io/">Angular</a>, a popular front-end Web-development framework, to develop a more advanced and dynamic version of markdown editor client. The implementation in Project 3 will save all blog posts created by the user <em>locally within the browser</em>, without any interaction with the server. In Project 4, you will then implement the server-side code, on Node.js and Express, to store and publish the user's posts online. Combined together, you will go through a full-stack Web-development cycle on the MEAN stack, an approach popular among many Web start-ups today.</p>
<p>Note that your implementation of Project 3 will be used for your Project 4 as well. Since Project 4 is dependent on Project 3, it is important that you <strong>follow instructions on this spec exactly</strong> to avoid any potential issues later in Project 4.</p>
<h2 id="development-environment">Development Environment</h2>
<p>All development for Projects 3 (and 4) will be done on a Docker container based on the "junghoo/cs144-mean" image:</p>
<pre class="term"><code>$ docker run -it -p3000:3000 -p4200:4200 -p8080:8080 -p49152:49152 -v {host_shared_dir}:/home/cs144/shared --name mean junghoo/cs144-mean</code></pre>
<p>Make sure to replace <code>{host_shared_dir}</code> with the name of the shared directory on your host. The above command creates a docker container named <code>mean</code> with appropriate port forwarding and directory sharing. Once created, you can start the container simply by issuing the following command in a terminal window:</p>
<pre class="term"><code>$ docker start -i mean</code></pre>
<p>This container has Node.js (v8.9.4), MongoDB (v3.6.2), and Angular CLI (v1.6.6) pre-installed. You can check their versions by the following commands.</p>
<pre class="term"><code>$ node --version
$ ng --version</code></pre>
<h2 id="part-a-learn-angular-and-basic-concepts">Part A: Learn Angular and Basic Concepts</h2>
<p>Angular is a front-end Web-development framework that makes it easy to build applications for the Web. Angular combines <em>declarative templates</em>, <em>dependency injection</em>, <em>end-to-end tooling</em>, and integrates best development practices to solve challenges in Web front-end development. Angular empowers developers to build applications that live on the Web, mobile, or the desktop.</p>
<p>Before starting on any materials related to Angular, first get yourself familiar with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript">JavaScript</a>, and new language constructs from <a href="https://babeljs.io/learn-es2015/">recent JavaScript standards</a> such as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">classes</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">modules</a>. The latest Angular version uses <a href="https://www.typescriptlang.org/">TypeScript</a>, an extended version of JavaScript, as its primary language. Fortunately, most Angular code can be written with just the latest JavaScript, with a few additions like <a href="https://www.typescriptlang.org/docs/handbook/classes.html">types</a> for dependency injection, and <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">decorators</a> for metadata. We will go over essential TypeScript for Angular in class, but you may want to go over <a href="http://oak.cs.ucla.edu/classes/cs144/notes/html/typescript.html">the class lecture notes</a> now to learn the basic TypeScript.</p>
<p>Angular official website provides an excellent introductory tutorial on Angular development: <a href="https://angular.io/tutorial">Tour of Heroes tutorial</a>. It introduces the fundamental concepts for Angular development by building a simple demo application.</p>
<ul>
<li><a href="https://angular.io/tutorial">Tour of Heroes tutorial</a></li>
</ul>
<p>It may take some time to finish this tutorial, but we believe <strong>following this tutorial is still the most effective and time-saving way to get yourself familiar with the Angular development</strong>. Please note that when you follow the tutorial using the Angular CLI preinstalled in our container, you will need to use the following command to "run" your Angular code:</p>
<pre class="term"><code>$ ng serve --host 0.0.0.0</code></pre>
<p>not <code>ng serve --open</code> as described in the tutorial.</p>
<p><strong>Note on <code>--host</code> option:</strong> By default, Angular HTTP server binds to only "localhost". This means that if any request comes from other than localhost, it does not get it. When Angular runs on the same machine as the browser, this is not a problem. Angular binds to localhost and the browser sends a request to localhost. But when Angular runs in a docker container, the localhost of Angular is different from the localhost of the browser. Angular sees localhost of <em>container</em> and browser sees the localhost of the <em>host</em>. By adding "--host 0.0.0.0", we instruct Angular to bind to <em>all network interfaces</em> within the container, not just localhost, so that Angular is able to get and respond to a request forwarded by Docker through network forwarding.</p>
<p>If you have previous Angular or similar Web-framework development experience, you can choose to read the <a href="https://angular.io/guide/architecture">Angular documentation</a> directly instead. However, for most students who have not worked with Angular extensively before, reading the documentation may take more time than following the step-by-step tutorial. Thus, our recommendation is to start with the tutorial and then go over the documentation after you get familiar with the basics.</p>
<p><strong>Some caveats: Do not confuse Angular with AngularJS!</strong> When you search for Angular related issues on the Internet, <strong>please use Angular 2 or Angular CLI as search keywords, not AngularJS.</strong> AngularJS is an older version of the Angular framework and is no longer a recommended version. The difference between the "old" AngularJS and the "new" Angular is quite extensive, as you can read from <a href="https://medium.com/@angularminds/comparison-between-angular-1-vs-angular-2-vs-angular-4-62fe79c379e3">more detailed comparison articles</a> on the Web. For our project, you may ignore previous AngularJS versions and just learn the latest Angular CLI using the links and tutorials provided in this spec.</p>
<p>After you finish the tutorial, go over the following questions and make sure you can answer them by yourself.</p>
<ul>
<li>What is a Component in Angular?</li>
<li>What is a Template? What are Directives in a Template?</li>
<li>What is a Module in Angular? How is NgModule different from a JavaScript module?</li>
<li>How does Angular support Data binding?</li>
<li>What is a Service and how is Dependency injection done in Angular?</li>
<li>How is Routing done in Angular?</li>
<li>What are commonly used Angular CLI commands, such as generating a component or service?</li>
</ul>
<p>Please read corresponding sections in <a href="https://angular.io/guide/architecture">the Angular documentation</a> for review if the answer to any question is not clear.</p>
<p>Now you have equipped with enough Angular knowledge to get started with Project 3. Good Luck!</p>
<h2 id="part-b-project-demo-and-requirements">Part B: Project Demo and Requirements</h2>
<p>Project 3 is all about a front-end markdown blog editor and previewer. It should be implemented as a <a href="https://en.wikipedia.org/wiki/Single-page_application">single-page application (SPA)</a>, which means that your entire application runs on a "single page." The website interacts with the user by dynamically updating only a part of the page rather than loading an entirely new page from the server. This approach avoids long waits between page navigation and sudden interruptions in the user interaction, making the application behave more like a traditional desktop application. A typical example of a SPA is <a href="https://gmail.com/">Gmail</a>.</p>
<p>An important feature of a SPA is that <strong>a specific state of the application is associated with the corresponding url</strong>, so that a user does not accidentally exit from the app by pressing a back button. When a user presses the browser back button, the user should go to the <em>previous state within the app</em> (unless the user just opened the app) as opposed to exiting from the app and go to the page visited before the app. As an example, open <a href="https://gmail.com/">Gmail</a>, click on a few mail messages and/or folder labels, and then press the browser back button. You will see that you do not exit from the Gmail app, even though all your interaction in the app happened on a <em>single page</em>, and, technically, the "previous page" in your visit history should be the page that you visited <em>before</em> you opened the Gmail app. In addition, if you cut and paste the Gmail's drafts folder URL <a href="https://gmail.com/#drafts" class="uri">https://gmail.com/#drafts</a> into the browser address bar, you will see that you directly land on the draft folder of Gmail, not its generic start page. You will soon learn how to implement this behavior by using the <em>routing module</em> of Angular.</p>
<p>We made a demo website of Project 3 available at <a href="http://oak.cs.ucla.edu/classes/cs144/project3/demo/" class="uri">http://oak.cs.ucla.edu/classes/cs144/project3/demo/</a>. It is rather simple and does not contain many CSS-styling instructions, but it still meets the key requirements of this project.</p>
<div style="clear: both;">

</div>
<figure>
<img src="./index_files/edit.png" style="float: right; width: 300px;">
</figure>
<p>In the first image, we show the <strong>edit view</strong> of the application, which allows the user edit a post. In this view, we require you to implement the following functionalities:</p>
<ul>
<li>The view shows one <code>text</code> input box for the title and one <code>textarea</code> for the body.</li>
<li>The "last modified" date and time is shown below the text boxes.</li>
<li>The view should contain at least three buttons, "save", "preview", and "delete".</li>
<li>The "save" button should be disabled (i.e., grayed out) unless the title or the body has been modified by the user.</li>
<li>When the "save" button is enabled, pressing the button should permanently save the post and update the last-modified date of the post to the current time.</li>
<li>When the user "exits" from this view (by pressing the "preview" button, by clicking on another post in the list, by pressing the browser "refresh" or "back" buttons, or by typing a URL into the address bar), any unsaved changes should be saved automatically, so that the <em>app never loses the user's work</em>.</li>
<li>When the "preview" button is clicked, the app should switch to the "preview view" (see below).</li>
<li>When the "delete" button is clicked, the post should disappear from the "list pane" (described below) and be permanently deleted.</li>
</ul>
<div style="clear: both;">

</div>
<figure>
<img src="./index_files/preview.png" style="float: right; width: 300px;">
</figure>
<p>In the second image, we show the <strong>preview view</strong> of the application. In this view, we require you to implement the following functionalities:</p>
<ul>
<li>The view shows an HTML-rendered preview of the current markdown post, including its title and body.</li>
<li>There is an "edit" button to switch to the edit view.</li>
</ul>
<div style="clear: both;">

</div>
<figure>
<img src="./index_files/list.png" style="float: right; width: 300px;">
</figure>
<p>In the third image, we show the "list pane", that should meet the following requirements:</p>
<ul>
<li>It shows the list of all blog posts that have been written by the user.</li>
<li>The posts in the list should be sorted by their "postid" (a unique integer assigned to a post) in the ascending order.</li>
<li>The postid assigned to each post should start with 1 and increase linearly by one.</li>
<li>Each post in the list must show the creation date &amp; time of the post and the title.</li>
<li>The user can add a new post anytime by clicking the "new post" button, which <strong>opens the edit view of the newly created post on the right side.</strong></li>
<li>The user can edit any of existing post by clicking its entry in the list, which <strong>opens the edit view of the post on the right side.</strong></li>
</ul>
<p>Note that differently from Project 2, you are required to make the markdown editor as a single-page application and <strong>the "list pane" should be always visible on the left side</strong> of either edit or preview view.</p>
<p>In addition, when the user presses the browser's "back button", the user should go to the "previous state" of the app, not to the page visited prior to your app. For example, If the user opened the app, clicked on the first post in the list pane, and pressed the "preview" button, the user should go to the state before the "preview" button was pressed if the user clicks on the browser back button. It should also be possible for the user to simply "bookmark" the current URL in the address bar, so that the user can come back to exactly the same state of the application through the bookmarked URL. In particular, you need to associate the three "states" of our app with the following URL patterns:</p>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">URL</th>
<th style="text-align: left;">state</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>/</code></td>
<td style="text-align: left;">This default path shows only the list pane, without showing the edit or preview view</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>/edit/:id</code></td>
<td style="text-align: left;">This path shows the list pane and the "edit view" for the post with <code>postid=id</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>/preview/:id</code></td>
<td style="text-align: left;">This path shows the list pane and the "preview view" of the post with <code>postid=id</code></td>
</tr>
</tbody>
</table>
<p>Finally, all user-created blog posts must be stored locally in the browser using <a href="https://www.w3schools.com/html/html5_webstorage.asp">html5 localStorage</a> in Project 3 and the preview page should be generated by a JavaScript code running inside the browser, using the <a href="https://github.com/commonmark/commonmark.js">commonmark.js</a> library. In short, there must be <strong>NO COMMUNICATION</strong> between the browser and the server once the app has been loaded, i.e., no GET or POST requests should be generated by your app. Everything should be handled by the JavaScript code in the browser with no interaction with the server.</p>
<h2 id="part-c-create-project-skeleton-using-angular-cli">Part C: Create Project Skeleton using Angular CLI</h2>
<p>Now it is time to start working on the project using the Angular Command-Line Interface (CLI). First create a new Angular application using the following command:</p>
<pre class="term"><code>$ ng new angular-blog</code></pre>
<p>This may take a while since a lot of files are fetched and generated. When the skeleton application is created successfully, we will see the following output.</p>
<pre class="term"><code>Project 'angular-blog' successfully created.</code></pre>
<p>You can launch the just-created application using <code>ng serve --host 0.0.0.0</code> and access it in your browser at <a href="http://localhost:4200/" class="uri">http://localhost:4200/</a>. <strong>Do not forget <code>--host 0.0.0.0</code> as we are serving the Angular app from the container.</strong></p>
<pre class="term"><code>$ ng serve --host 0.0.0.0</code></pre>
<p>The page you see is the application shell. The shell is controlled by an Angular component named <em>AppComponent</em>.</p>
<p>Components are fundamental building blocks of any Angular application. They display data on the screen, listen for user input, and take an action based on that input.</p>
<p>The <code>angular-blog</code> directory that contains the initial skeleton code looks like the following:</p>
<pre><code>angular-blog
 +- e2e
 +- node_modules
 +- src 
    +- app
        +- app.component.css
        +- app.component.html
        +- app.component.spec.ts
        +- app.component.ts
        +- app.module.ts
    +- assets
    +- environments
    +- index.html
    +- styles.css
    +- typings.d.ts
    +- ...
 +- package.json
 +- README.md
 +- ...</code></pre>
<p>This may look like a lot of files at the first glance, but don't get overwhelmed. The files you need to touch are <em>all inside the <code>src/app</code> folder</em>. Other files can be ignored in most cases. In the <code>src/app</code> folder, the Angular CLI has created the <em>root module</em>, <code>AppModule</code>, and the main application component, <code>AppComponent</code>.</p>
<p>You'll find the implementation of <code>AppComponent</code> distributed over three files:</p>
<ul>
<li>app.component.ts — the component class file, written in TypeScript.</li>
<li>app.component.html — the component template, written in HTML.</li>
<li>app.component.css — the component's style, written in CSS.</li>
</ul>
<p>The ".spec.ts" file is used for unit testing, and you can ignore it for now.</p>
<p>Refer to the <a href="https://angular.io/tutorial/toh-pt0">Application Shell</a> section of the tutorial if you still have confusions about how these files work together to form a component.</p>
<h2 id="part-d-implement-blog-service">Part D: Implement Blog Service</h2>
<p>Now you create a "Blog Service" using the following command:</p>
<pre class="term"><code>$ ng generate service blog --module=app</code></pre>
<p>The option <code>--module=app</code> inserts the necessary <code>imports</code> and <code>providers</code> statements to the <code>AppModule</code>, so that you don't have to add them yourself. You will see the service files created in the terminal.</p>
<pre class="term"><code>  create src/app/blog.service.spec.ts (362 bytes)
  create src/app/blog.service.ts (110 bytes)</code></pre>
<p>The <code>BlogService</code> plays two important roles in our application.</p>
<ol type="1">
<li><p>It allows other components in the application to store and retrieve blog posts. This service hides the exact storage mechanism of the blog posts, so that other components can be implemented independently of the storage mechanism. In fact, in Project 3, all blog posts are stored locally within the browser using <a href="https://www.w3schools.com/html/html5_webstorage.asp"><code>localStorage</code></a>, while in Project 4, they will be stored in a remote server. Despite this change, you won't have to change other code of your application, except <code>BlogService</code>.</p></li>
<li><p><code>BlogService</code> works as a "local memory cache" for blog posts, so that (potentially) long delays of the underlying storage mechanism is hidden to other components. While this is not an important issue for Project 3 because blog posts is stored locally, this will become particularly important in Project 4 when posts are stored in a remote server.</p></li>
</ol>
<p>Now, open the <code>blog.service.ts</code> file and declare a <code>Post</code> class with the following properties:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">export</span> <span class="kw">class</span> Post <span class="op">{</span>
  <span class="dt">postid</span><span class="op">:</span> number<span class="op">;</span>
  <span class="dt">created</span><span class="op">:</span> Date<span class="op">;</span>
  <span class="dt">modified</span><span class="op">:</span> Date<span class="op">;</span>
  <span class="dt">title</span><span class="op">:</span> string<span class="op">;</span>
  <span class="dt">body</span><span class="op">:</span> string<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Note that we need to <code>export</code> this class, so that it can be imported and used by other components of the application. <code>postid</code> is the unique id of the blog post, <code>created</code> and <code>modified</code> are the post's creation and last modification date and time, <code>title</code> and <code>body</code> are the actual content of the post formatted in markdown.</p>
<p>Add a private <code>posts</code> property to the <code>BlogService</code> class like the following:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">  <span class="kw">private</span> posts<span class="op">:</span> Post[]<span class="op">;</span></code></pre></div>
<p>The property <code>posts</code> works as the "memory cache" of all blog posts. When the application starts running, all blog posts by the user will be retrieved from the underlying storage mechanism and be held here. In addition, any changes to a post will be temporarily held here until they are permanently written to the underlying storage.</p>
<p>Now implement the following methods in the <code>BlogService</code> class:</p>
<ul>
<li><code>fetchPosts(): void</code> - This method "populates" the <code>posts</code> property by retrieving all all blog posts from <code>localStorage</code>. This function must be called inside the constructor so that all posts are retrieved and be ready in memory when <code>BlogService</code> is created.</li>
<li><code>getPosts(): Post[]</code> - This method simply returns <code>posts</code></li>
<li><code>getPost(id: number): Post</code> - Find the post with <code>postid=id</code> from <code>posts</code> and return it.</li>
<li><code>newPost(): Post</code> - Create a new post with a new postid, an empty title and body, and current creation and modification times, save it to <code>localStorage</code>, add it to <code>posts</code>, and return it. The postid of a new post should start at 1 and increase linearly.</li>
<li><code>updatePost(post: Post): void</code> - From <code>posts</code>, find a post whose <code>postid</code> is the same as <code>post.postid</code>, update its title and body with the passed-in values, change its modification time to now, and update the post in <code>localStorage</code>. If no such post exists, do nothing.</li>
<li><code>deletePost(id: number): void</code> - From <code>posts</code>, find a post whose <code>postid=id</code>, delete it from <code>posts</code>, and delete a corresponding post from <code>localStorage</code>. If no such post exists, do nothing.</li>
</ul>
<p><strong>Notes</strong></p>
<ol type="1">
<li>In Project 4, you will need to update the blog service to perform these operations through HTTP on a remote <em>server</em>, as opposed to <code>localStorage</code>. To make this later update contained, it is important that you implement the above methods exactly as specified.</li>
<li>When you modify <code>posts</code>, an array of <code>Post</code>, in the above methods, keep in mind that <strong>mutators, such as <code>splice()</code>, <code>push()</code>, and <code>shift()</code>, directly modify the input array, while accessor methods, such as <code>slice()</code>, <code>filter()</code>, and <code>map()</code>, don't. Accessor methods create a completely new copy of the output array, leaving the original input array in tact.</strong></li>
<li>To simplify things further, you may assume that all update/save operations to <code>localStorage</code> are completed successfully without any error (e.g., you may assume that you never get "out of space" error from update).</li>
</ol>
<p>In the rest of the project spec, we describe more detailed guidance on how you can implement the rest of Project 3. However, keep it mind that the rest of our project description is a <em>suggestion, not a requirement</em>. As long as your code meets the requirements in Part B and implements the methods of <code>BlogService</code> exactly as described in Part D, you can implement the rest of your application however you want. We provide further description here in case you need more guidance and help to finish this project.</p>
<h2 id="part-e-implement-list-and-edit-components">Part E: Implement List and Edit Components</h2>
<p>Roughly, our editor may be split into three different components:</p>
<ol type="1">
<li><p><em>List component</em>: This component is responsible for displaying the "list pane". This component should be visible on the left side of the app all the time. The user should be able to click on a post in the list to "edit" it.</p></li>
<li><p><em>Edit component</em>: This component is responsible for the "edit view" of the app. When the user clicks on a post in the list pane, this component should be displayed on the right side of the list and let the user edit the title and body of the post. It should also contain a buttons for "save", "delete", and "preview".</p></li>
<li><p><em>Preview component</em>: This component is responsible for the "preview view" of the app. When the user clicks on the "preview" button in the edit component, this component should replace the edit component and show the HTML version of the post.</p></li>
</ol>
<h3 id="add-the-edit-component">Add the Edit Component</h3>
<p>Now let us create the edit component:</p>
<pre class="term"><code>$ ng generate component edit</code></pre>
<p>Note that all components in our app, including <code>EditComponent</code>, needs to use <code>BlogService</code> to retrieve and/or update blog posts. Thus, you will have to import <code>Post</code> and <code>BlogService</code> classes in <code>edit.component.ts</code> through an import statement. Also, you will need to make <code>BlogService</code> available in <code>EditComponent</code> through dependency injection by modifying the component's constructor signature. If this sounds confusing, go over the <a href="https://angular.io/tutorial">Angular tutorial</a> again, in particular the <a href="https://angular.io/tutorial/toh-pt4">services</a> section. The Angular documentation on <a href="https://angular.io/guide/dependency-injection">dependency injection</a> can also be helpful.</p>
<p>Also, add <code>post: Post</code> as a property of <code>EditComponent</code>, which will hold a copy of the post that is being currently edited.</p>
<p>Remember that <code>EditComponent</code> is responsible for the following user interactions:</p>
<ol type="1">
<li>The title and body of the current post should appear in <code>text</code> input and <code>textarea</code>, respectively, so that the user can edit them.</li>
<li>When the user clicks on the "preview" button, any unsaved changes should be saved, and the "preview view" should open.</li>
<li>The "save" button should be disabled by default until the user makes changes to either the title or the body. When the user clicks on the "save" button, all changes should be saved to <code>localStorage</code> (via <code>BlogService</code>) and the "save" button should be disabled again.</li>
<li>When the user tries to leave the edit view, all unsaved changes should be automatically saved to <code>localStorage</code> (via <code>BlogService</code>), so that no work is lost.</li>
</ol>
<p>To support the above interactions, remove the auto-generated HTML code in<br>
the template, <code>edit.component.html</code>, and add necessary HTML elements. In modifying the template, you may find the following information useful:</p>
<ul>
<li>Data can be dynamically exchanged between a template element and a component property using Angular's <a href="https://angular.io/guide/template-syntax#two-way-binding---"><em>two-way binding</em></a> and the <a href="https://angular.io/guide/template-syntax#ngModel"><code>ngModel</code> directive</a> (e.g., <code>[(ngModel)]="post.title"</code>). This mechanism can be used, for example, to support displaying and editing the post's title. Note that <a href="https://angular.io/tutorial/toh-pt1#import-formsmodule"><code>FormsModule</code></a> needs to be imported in the <em>RootModule</em>, <code>app.module.ts</code>, if you want to use the <code>ngModel</code> directive.</li>
<li>You can use <a href="https://angular.io/guide/template-syntax#interpolation----"><em>interpolation</em></a> (e.g., <code>{{post.modified}}</code>) if you want to display a property value in the template.</li>
<li>You can use <a href="https://angular.io/tutorial/toh-pt2#add-a-click-event-binding"><em>event binding</em></a> (e.g., <code>(click)="delete()"</code>), to call a method of the component for a triggered event.</li>
<li>You can disable a button by setting the <code>disabled</code> property of the button to true, like <code>[disabled]="true"</code>. You can check whether a value in a form input has been modified using the <code>dirty</code> property of <a href="https://angular.io/api/forms/FormControl"><code>FormControl</code></a>. You can clear the <code>dirty</code> property by calling <code>markAsPristine()</code> of the <code>FormControl</code>. To learn how you can create a <code>FormControl</code> in the component and how to associate it with an input element in the template, the <a href="https://angular.io/guide/reactive-forms">reactive forms</a> page of the Angular documentation will be helpful.</li>
<li>You can use the <a href="https://angular.io/guide/template-syntax#ngif"><em>structural directive</em> <code>*ngIf</code></a> or the <a href="https://angular.io/guide/template-syntax#safe-navigation-operator"><em>safe navigation operator</em> <code>?.</code></a> to guard against <code>null</code> or <code>undefined</code> values in a property.</li>
</ul>
<p>Add CSS rules to <code>edit.component.css</code> to make the component look reasonable.</p>
<p>Once you finish updating the template and CSS style, implement the functionalities described above to the component class, <code>edit.component.ts</code>. In particular, you may want to add one "event handler" method per each button-click event with the names like <code>save()</code>, <code>delete()</code>, and <code>preview()</code>. Note that you may not be able to implement <code>preview()</code> method yet, since you need to implement the preview component first to switch to the "preview view".</p>
<h3 id="test-the-edit-component">Test the Edit Component</h3>
<p>In order to display <code>EditComponent</code> in your app, you must add it as a child component of <code>AppComponent</code>. Add <code>&lt;app-edit&gt;&lt;/app-edit&gt;</code> to <code>src/app/app.component.html</code> as follow to test your implementation of <code>EditComponent</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1&gt;</span>{{title}}<span class="kw">&lt;/h1&gt;</span>
<span class="kw">&lt;app-edit&gt;&lt;/app-edit&gt;</span></code></pre></div>
<p>Even after this addition, you may not see any output from <code>EditComponent</code> when you run <code>ng serve --host 0.0.0.0</code>. This is because the <code>post</code> property of <code>EditComponent</code> is never initialized to a value in your code yet. You will add the proper initialization code for <code>post</code> after you implement other components. For now, assign a fake value to <code>post</code> like the following in, say, the constructor:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">  <span class="kw">this</span>.<span class="at">post</span> <span class="op">=</span> <span class="op">{</span>
    <span class="dt">postid</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span>
    <span class="dt">created</span><span class="op">:</span> <span class="kw">new</span> <span class="at">Date</span>()<span class="op">,</span>
    <span class="dt">modified</span><span class="op">:</span> <span class="kw">new</span> <span class="at">Date</span>()<span class="op">,</span>
    <span class="dt">title</span><span class="op">:</span> <span class="st">'title'</span><span class="op">,</span>
    <span class="dt">body</span><span class="op">:</span> <span class="st">'body'</span>
  <span class="op">};</span></code></pre></div>
<p>If you still have the <code>ng serve --host 0.0.0.0</code> command running, you should now see that the <code>EditComponent</code> displays the test data in the browser. After verifying that your <code>EditComponent</code> is working fine, remove the fake initialization code for <code>post</code> and remove <code>&lt;app-edit&gt;&lt;/app-edit&gt;</code> from <code>app.component.html</code>.</p>
<p><strong>Note:</strong> In case the <code>ng serve</code> does not auto-rebuild your app after a file is changed, make sure that you forwarded port 49152 when you initially set up the container. Otherwise auto-rebuild does not work. Some students also report that "ng serve" does not auto-rebuild even with proper port forwarding, particularly on a Windows machine. If that is the case, try <code>ng serve --host 0.0.0.0 --poll=2000</code>. The development server will look for file changes every two seconds and compile if necessary.</p>
<h3 id="add-the-list-component">Add the List Component</h3>
<p>We now create the second non-root component, the list component.</p>
<pre class="term"><code>$ ng generate component list</code></pre>
<p>Make <code>Post</code> and <code>BlogService</code> available in <code>ListComponent</code> by including an appropriate import statement and modify its constructor signature to inject <code>BlogService</code> through dependency injection.</p>
<p>Remember that the list component needs to take the following actions depending on the user interaction:</p>
<ol type="1">
<li>It has to obtain all blog posts through <code>BlogService</code> and display them in a list on the left side of the app.</li>
<li>When the user clicks on the "new" button, it has to create a new post using <code>BlogService</code> and open the "edit view" for the post.</li>
<li>When the user clicks on a post in the list, it has to open the "edit view" for the post.</li>
</ol>
<p>To display the list component in our app, you need to make it a child of <code>AppComponent</code> by including its component directive. You may also find Angular's <a href="https://angular.io/guide/template-syntax#built-in-structural-directives"><em>structural directives</em></a> helpful in displaying the list of posts it obtains from <code>BlogService</code>.</p>
<p>The third action, opening the "edit view" when the user clicks on a post can be implemented in a number of different ways, but given our requirements in Part B, the best way might be using a <em>router</em>, which will be explained in the next part.</p>
<h2 id="part-f-add-the-approutingmodule">Part F: Add the AppRoutingModule</h2>
<p>As we mentioned earlier, an important feature of the single-page application is that <strong>a specific state of the application is associated with the corresponding url</strong>. In particular, you need to associate the three "states" of our app with the following URL patterns:</p>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">URL</th>
<th style="text-align: left;">state</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>/</code></td>
<td style="text-align: left;">This default path shows only the list pane, without showing the edit or preview view</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>/edit/:id</code></td>
<td style="text-align: left;">This path shows the list pane and the "edit view" for the post with <code>postid=id</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>/preview/:id</code></td>
<td style="text-align: left;">This path shows the list pane and the "preview view" of the post with <code>postid=id</code></td>
</tr>
</tbody>
</table>
<p>Associating a URL with a particular state of the application and displaying a different component based on the state can be achieved through a <em>router</em> in Angular. If you do not remember what a router is or how to use it, go over the Angular tutorial again, in particular the <a href="https://angular.io/tutorial/toh-pt5">routing section</a>. It may be useful to look at the <a href="https://angular.io/guide/router">routing &amp; navigation section</a> of the Angular documentation.</p>
<p>Angular's best practice is to load and configure the router in a separate, top-level module that is dedicated to routing and import it in the root AppModule. By convention, the class dedicated for a routing module is named as <code>AppRoutingModule</code> and can be generated using the following CLI command:</p>
<pre class="term"><code>$ ng generate module app-routing --flat --module=app</code></pre>
<p>The <code>--flat</code> option creates <code>app-routing.module.ts</code> directly in <code>src/app</code> not in its own subdirectory. The <code>--module=app</code> option adds necessary import statements to the <em>RootModule</em>, <code>app.module.ts</code>. Open <code>app-routing.module.ts</code> and update its content as follows:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span> NgModule <span class="op">}</span> <span class="im">from</span> <span class="st">'@angular/core'</span><span class="op">;</span>
<span class="im">import</span> <span class="op">{</span> RouterModule<span class="op">,</span> Routes <span class="op">}</span> <span class="im">from</span> <span class="st">'@angular/router'</span><span class="op">;</span>
<span class="im">import</span> <span class="op">{</span> EditComponent <span class="op">}</span> <span class="im">from</span> <span class="st">'./edit/edit.component'</span><span class="op">;</span>

<span class="kw">const</span> routes<span class="op">:</span> Routes <span class="op">=</span> [
  <span class="op">{</span> <span class="dt">path</span><span class="op">:</span> <span class="st">'edit/:id'</span><span class="op">,</span> <span class="dt">component</span><span class="op">:</span> EditComponent <span class="op">}</span>
]<span class="op">;</span>

@<span class="at">NgModule</span>(<span class="op">{</span>
  <span class="dt">imports</span><span class="op">:</span> [ <span class="va">RouterModule</span>.<span class="at">forRoot</span>(routes<span class="op">,</span> <span class="op">{</span><span class="dt">useHash</span><span class="op">:</span> <span class="kw">true</span><span class="op">}</span>) ]<span class="op">,</span>
  <span class="dt">exports</span><span class="op">:</span> [ RouterModule ]
<span class="op">}</span>)
<span class="im">export</span> <span class="kw">class</span> AppRoutingModule <span class="op">{</span> <span class="op">}</span></code></pre></div>
<p>In the above code, the <code>routes</code> config maps the URL pattern <code>edit/:id</code> to the <code>EditComponent</code>. (Mapping the the URL pattern <code>preview/:id</code> to the <code>PreviewComponent</code> need to be added later after we implement the "preview component". The path <code>/</code> does not need a mapping since the app does not need to display any component other than the list component for <code>/</code>.)</p>
<p>Add a <a href="https://angular.io/guide/router#router-outlet">router outlet</a> in <code>app.component.html</code>, so an appropriate component will be displayed if the URL pattern matches to a route:</p>
<p>Now that we have the URL-to-component mapping in place through <code>RouterModule</code>, we need to modify our code to implement the correct routing behavior. In particular, we have to add the following logic to our code:</p>
<ol type="1">
<li>When the user clicks on a post in the list, our app should "navigate" to the URL <code>edit/:id</code>, where <code>:id</code> is the <code>postid</code> of the clicked post.</li>
<li>When the app navigates to <code>edit/:id</code> and the <code>RouterModule</code> displays <code>EditComponent</code> in the router outlet, our <code>EditComponent</code> should retrieve the post whose <code>postid</code> is <code>:id</code> and update its template elements accordingly.</li>
<li>When the user clicks the "delete" button in the <code>EditComponent</code>, the component should delete the current post through <code>BlogService</code> and navigate to the URL <code>/</code>, so that <code>EditComponent</code> is no longer displayed in the router outlet.</li>
<li>When the user "navigates away" from the "edit view", any unsaved work by the user should be automatically saved.</li>
<li>When the user clicks on the "preview" button in the <code>EditComponent</code>, the component should save any unsaved changes and navigate to the URL <code>preview/:id</code>, where <code>:id</code> is the <code>postid</code> of the current post.</li>
</ol>
<p>To implement the above functionality, you may find the following information helpful:</p>
<ol type="1">
<li>Within your component method, you can "navigate" to a particular URL by calling the <code>navigate()</code> method of the <a href="https://angular.io/api/router/Router"><code>Router</code></a> object, like <code>router.navigate(['/'])</code>. Inside a template, you can use the <code>routerLink</code> directive, like <code>&lt;a routerLink="/"&gt;</code>, to have the same effect when the user clicks on the link.</li>
<li>You can obtain the <code>:id</code> part of an "activated URL" (or "activated route") with the <a href="https://angular.io/api/router/ActivatedRoute"><code>ActivatedRoute</code></a> object, by calling <code>activatedRoute.snapshot.ParamMap.get('id')</code>.</li>
<li><p>The <code>EditComponent</code> can "subscribe" to the "URL activation event" -- so that whenever a new URL is activated, it can retrieve the correct post from <code>BlogService</code> and update its elements -- using the <code>ActivatedRoute</code> object. For example, the following code</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">activatedRoute</span>.<span class="va">params</span>.<span class="at">subscribe</span>(() <span class="op">=&gt;</span> <span class="kw">this</span>.<span class="at">getPost</span>())<span class="op">;</span></code></pre></div>
will ensure <code>getPost()</code> method to be called whenever the route is activated.</li>
<li><p>To save the user's unsaved edits in the "edit view" when the user presses the browser's refresh button, etc., you may want to intercept the "beforeunload" (or "unload") event of the global <code>window</code> object. In Angular, a method can be declared to be called for a general browser event by decorating it with the <code>@HostListener(event)</code> decorator. For example, if you decorate a method of <code>EditComponent</code> with <code>@HostListener('window:beforeunload')</code>, the method will be called whenever "beforeunload" event is triggered to the global <code>window</code> object.</p></li>
</ol>
<p>To be able to use <code>Router</code> and <code>ActivatedRoute</code> objects in <code>EditComponent</code>, update its constructor signature to make the two classes available through dependency injection.</p>
<p>If you use <code>@HostListener</code> decorator in <code>EditComponent</code>, you will need to import it in <code>edit.component.ts</code> by including the following import statement:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span> HostListener <span class="op">}</span> <span class="im">from</span> <span class="st">'@angular/core'</span><span class="op">;</span></code></pre></div>
<p>Now your web application should have all functionalities implemented except "preview".</p>
<h2 id="part-g-add-the-preview-component">Part G: Add the Preview Component</h2>
<p>You should be fairly familiar with the Angular development process if you finished all previous parts and reached here. In this part, most of the tasks are similar to what you have done already, so we provide a minimal guidance.</p>
<p>First you need to add the <em>preview</em> component through the Angular Cli. Then add the the route mapping from <code>preview/:id</code> to this component in your routing module.</p>
<p>For markdown to HTML rendering, we will use <a href="https://github.com/commonmark/commonmark.js">CommonMark.js library</a>, so install the <code>commonmark</code> module through the following command:</p>
<pre class="term"><code>$ npm install --save commonmark</code></pre>
<p>Open <strong>preview.component.ts</strong>, add the following import statement</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span> Parser<span class="op">,</span> HtmlRenderer <span class="op">}</span> <span class="im">from</span> <span class="st">'commonmark'</span><span class="op">;</span></code></pre></div>
<p>to use commonmark's <code>Parser</code> and <code>HtmlRenderer</code> objects in your code. Note that commonmark.js's API is almost identical to the Java version, so you will find it easy to use.</p>
<p>Update the constructor signature of <code>PreviewComponent</code> with necessary dependencies and add the appropriate <code>import</code> statements. Subscribe to the URL activation event, so that the correct post is retrieved from <code>BlogService</code> and rendered as HTML when a "preview URL" is activated. Edit <strong>preview.component.html</strong> and <strong>preview.component.css</strong> to add the HTML elements and css rules needed for the component.</p>
<p>Finally, make sure that you update <code>EditComponent</code>, so that it correctly handles the user's click event on the "preview" button.</p>
<p>Congratulations! You now have finished all the requirements and functionalities of the project.</p>
<h2 id="part-h-test-your-project-locally">Part H: Test your project locally</h2>
<p>To check the state of your web application in browser, you can open the angular live development server using <code>ng serve --host 0.0.0.0</code> and you can check your work at <code>http://localhost:4200/</code>.</p>
<pre class="term"><code>$ ng serve --host 0.0.0.0</code></pre>
<p>Note you can leave the terminal open so that whenever you make any more change to the project, the browser window will be automatically refreshed.</p>
<p>Please check your web application is shown in the browser correctly and you can complete the post create, update, delete and preview tasks without any issues. Also, the post list should be always be displayed on the left side of any page and be updated whenever a new blog is created or an existing blog is updated or deleted.</p>
<p>Further, please check that by typing a URL directly in the address bar, you can directly jump to the corresponding edit or preview views. For example, <a href="http://localhost:4200/#/edit/1" class="uri">http://localhost:4200/#/edit/1</a> or <a href="http://localhost:4200/#/preview/1" class="uri">http://localhost:4200/#/preview/1</a>, should show the the first post's edit or preview view, respectively.</p>
<p>Lastly, please verify your application does not throw any errors in the javascript console. This can be checked in chrome by right clicking the browser window and choose "inspect". Then choose the "Console" tab to verify if any errors are appearing. Also, the saved blog posts should persist in the local storage. It can be verified by quitting and restarting the browser and check if all saved blog posts are still there.</p>
<h2 id="submit-your-project">Submit Your Project</h2>
<p>After you have checked there is no issue with your project, you can package your work by running our <a href="http://oak.cs.ucla.edu/classes/cs144/project3/package.sh">packaging script</a>. Please first create the <em>TEAM.txt</em> file and put your team's uid(s) in it. This file must include the 9-digit university ID (UID) of every team member, <strong>one UID per line. No spaces or dashes.</strong> Just 9-digit UID per line. If you are working on your own, include just your UID. Please make sure <strong>TEAM.txt and package.sh are placed in the project-root directory</strong>, <em>angular-blog</em>, like this:</p>
<pre><code>angular-blog
 +- e2e
 +- node_modules
 +- src 
      +- app
           +- ...
      +- assets
      +- environments
      +- index.html
      +- styles.css
      +- typings.d.ts
      +- ...
 +- package.sh
 +- TEAM.txt
 +- ...</code></pre>
<p>When you execute the packaging script like <code>./package.sh</code>, it will build a deployment version of your project and package it together with your source code and the <em>TEAM.txt</em> file into a single zip file named <strong>project3.zip</strong>. You will see something like this if the script succeeds:</p>
<pre><code>[SUCCESS] Created '/home/cs144/shared/angular-blog/project3.zip', please submit it to CCLE.</code></pre>
<p><strong>Please only submit this script-created project3.zip to CCLE. Do not use any other ways to package or submit your work!</strong></p>
<h2 id="grading-criteria">Grading Criteria</h2>
<p>We will grade your Project 3 mainly based on the functionalities. Specifically, we will test following things:</p>
<ul>
<li><strong>Post List</strong>: Post list is always shown on the left side of any page, and is updated whenever a blog is created, updated or deleted.</li>
<li><strong>Post Operations</strong>: Create, Update and Delete blogs without any issues.</li>
<li><strong>Post Preview</strong>: Render the markdown blog correctly and be able to return to the edit view from the preview view.</li>
<li><strong>URL Navigation</strong>: User can access a state of your application (e.g. edit or preview a specific blog) by directly typing the url.</li>
<li><strong>Local Storage</strong>: The blog entries should persist on the local storage no matter the browser window is closed or re-opened.</li>
<li><strong>User Interface</strong>: The User Interface should at least adopt the similar CSS decorations like what is done in demo. <strong>Better decorations may gain extra credit, but no more than 10%</strong>.</li>
<li><strong>No Errors</strong>: JavaScript Errors are very severe issues, we will <strong>deduct 20% of total points for each type of the error</strong> that appears on the browser console.</li>
<li><strong>Other Requirements in Description:</strong> For example, auto-save behavior, "disabled" save button if no modification, etc.</li>
</ul> 


</body></html>